import java.nio.file.*;
import java.util.*;
import java.util.regex.*;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;

public class ExtractAndRenameDeep {

    public static void main(String[] args) throws Exception {
        // USAGE:
        //   java ExtractAndRenameDeep blocks.txt records.json output.json
        Path blocksPath  = Paths.get(args.length > 0 ? args[0] : "blocks.txt");   // file with export const sections
        Path recordsPath = Paths.get(args.length > 1 ? args[1] : "records.json"); // JSON array
        Path outputPath  = Paths.get(args.length > 2 ? args[2] : "output.json");

        // 1) Build prop -> label (question) map
        String blocks = new String(Files.readAllBytes(blocksPath), "UTF-8");
        HashMap<String,String> propToLabel = extractPropToLabel(blocks);

        System.out.println("Mappings found: " + propToLabel.size());
        propToLabel.entrySet().stream().limit(5)
            .forEach(e -> System.out.println("  " + e.getKey() + " -> " + e.getValue()));
        if (propToLabel.isEmpty()) {
            System.err.println("No mappings parsed. Check your blocks file formatting.");
            return;
        }

        // 2) Read JSON array
        ObjectMapper om = new ObjectMapper();
        List<Object> rootArray = om.readValue(
                Files.newBufferedReader(recordsPath),
                new TypeReference<List<Object>>() {}
        );

        // 3) Deep rename across entire structure
        List<Object> transformed = new ArrayList<>(rootArray.size());
        for (Object node : rootArray) {
            transformed.add(deepRename(node, propToLabel));
        }

        // 4) Write output
        ObjectWriter writer = om.writer(new DefaultPrettyPrinter());
        writer.writeValue(outputPath.toFile(), transformed);
        System.out.println("Wrote " + transformed.size() + " records -> " + outputPath.toAbsolutePath());
    }

    /* ==================== Deep renaming ==================== */

    @SuppressWarnings("unchecked")
    private static Object deepRename(Object node, HashMap<String,String> propToLabel) {
        if (node == null) return null;

        if (node instanceof Map) {
            // Preserve insertion order
            LinkedHashMap<String,Object> input = new LinkedHashMap<>((Map<String,Object>) node);
            LinkedHashMap<String,Object> out = new LinkedHashMap<>();

            for (Map.Entry<String,Object> e : input.entrySet()) {
                String key = e.getKey();
                Object val = e.getValue();
                // Recurse first so nested keys also get renamed
                Object newVal = deepRename(val, propToLabel);

                String mapped = propToLabel.get(key.toLowerCase(Locale.ROOT));
                String newKey = (mapped != null && !mapped.isEmpty()) ? mapped : key;

                // Collision policy: last wins. If you want "first wins", only put if absent.
                out.put(newKey, newVal);
            }
            return out;
        }

        if (node instanceof List) {
            List<?> list = (List<?>) node;
            List<Object> out = new ArrayList<>(list.size());
            for (Object item : list) {
                out.add(deepRename(item, propToLabel));
            }
            return out;
        }

        // Primitive: leave as is
        return node;
    }

    /* ==================== Mapping extraction ==================== */
    /**
     * Build HashMap<propLower, label> from export-const sections.
     * Tolerant to formatting:
     *  - scans ANY {...} block,
     *  - accepts Label or Question,
     *  - accepts Prop or Property,
     *  - single/double quotes, any whitespace, any order.
     */
    private static HashMap<String,String> extractPropToLabel(String text) {
        HashMap<String,String> map = new HashMap<>();

        // Normalize smart quotes
        text = text.replace('“','"').replace('”','"').replace('’','\'').replace('‘','\'');

        // Find any { ... } region
        Pattern braces = Pattern.compile("\\{(.*?)\\}", Pattern.DOTALL);

        // Fields (case-insensitive)
        Pattern pLabelOrQuestion = fieldPattern("(?:Label|Question)");
        Pattern pProp            = fieldPattern("Prop(?:erty)?");

        Matcher mb = braces.matcher(text);
        while (mb.find()) {
            String body = mb.group(1);

            String label = first(pLabelOrQuestion, body);
            String prop  = first(pProp,            body);

            if (label != null && prop != null) {
                map.put(prop.trim().toLowerCase(Locale.ROOT), label.trim());
            }
        }
        return map;
    }

    private static Pattern fieldPattern(String keyNameRegex) {
        // Matches: KeyName : "value"  or  'value'
        return Pattern.compile("\\b" + keyNameRegex + "\\b\\s*:\\s*(['\"])(.*?)\\1",
                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
    }

    private static String first(Pattern p, String s) {
        Matcher m = p.matcher(s);
        return m.find() ? m.group(2) : null;
    }
}