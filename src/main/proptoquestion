import java.nio.file.*;
import java.util.*;
import java.util.regex.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;

public class RenameFromExportBlocksRobust {

    public static void main(String[] args) throws Exception {
        // USAGE:
        //   java RenameFromExportBlocksRobust blocks.txt records.json output.json
        Path blocksPath  = Paths.get(args.length > 0 ? args[0] : "blocks.txt");
        Path recordsPath = Paths.get(args.length > 1 ? args[1] : "records.json");
        Path outputPath  = Paths.get(args.length > 2 ? args[2] : "output.json");

        String blocksText = new String(Files.readAllBytes(blocksPath), "UTF-8");

        // Build prop(lowercase) -> label map
        Map<String,String> propToLabel = extractPropToLabel(blocksText);

        System.out.println("Loaded mappings: " + propToLabel.size());
        // Print a few samples for sanity
        propToLabel.entrySet().stream().limit(5).forEach(e ->
            System.out.println("  " + e.getKey() + " -> " + e.getValue())
        );
        if (propToLabel.isEmpty()) {
            System.err.println("No mappings found. Check your file formatting or keys.");
            return;
        }

        ObjectMapper om = new ObjectMapper();
        // Preserve object key order
        List<LinkedHashMap<String,Object>> rows = om.readValue(
            Files.newBufferedReader(recordsPath),
            new TypeReference<List<LinkedHashMap<String,Object>>>() {}
        );

        // Rename top-level keys per mapping (case-insensitive on the prop)
        List<Map<String,Object>> out = new ArrayList<>(rows.size());
        for (LinkedHashMap<String,Object> row : rows) {
            LinkedHashMap<String,Object> renamed = new LinkedHashMap<>();
            for (Map.Entry<String,Object> e : row.entrySet()) {
                String key = e.getKey();
                Object val = e.getValue();
                String label = propToLabel.get(key.toLowerCase(Locale.ROOT));
                renamed.put((label != null && !label.isEmpty()) ? label : key, val);
            }
            out.add(renamed);
        }

        ObjectWriter writer = om.writer(new DefaultPrettyPrinter());
        writer.writeValue(outputPath.toFile(), out);
        System.out.println("Wrote " + out.size() + " records -> " + outputPath.toAbsolutePath());
    }

    /**
     * Extracts Prop -> Label/Question from ANY {...} block in the file.
     * Tolerant to whitespace, commas, single/double quotes, order, and extra fields.
     */
    private static Map<String,String> extractPropToLabel(String text) {
        Map<String,String> map = new LinkedHashMap<>();

        // Normalize smart quotes if present
        text = text.replace('“','"').replace('”','"').replace('’','\'').replace('‘','\'');

        // Find any { ... } region; we’ll scan inside for fields
        Pattern braces = Pattern.compile("\\{(.*?)\\}", Pattern.DOTALL);
        Matcher mb = braces.matcher(text);

        // Field regexes (case-insensitive, allow single/double quotes)
        Pattern pLabel    = fieldPattern("(?:Label|Question)");
        Pattern pProp     = fieldPattern("Prop(?:erty)?");

        while (mb.find()) {
            String body = mb.group(1);

            String label = first(pLabel, body);
            String prop  = first(pProp,  body);

            if (label != null && prop != null) {
                String key = prop.trim().toLowerCase(Locale.ROOT);
                map.put(key, label.trim());
            }
        }
        return map;
    }

    private static Pattern fieldPattern(String keyNameRegex) {
        // Matches: KeyName : "value"  or  'value'  (value can span lines)
        return Pattern.compile("\\b" + keyNameRegex + "\\b\\s*:\\s*(['\"])(.*?)\\1",
                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
    }

    private static String first(Pattern p, String s) {
        Matcher m = p.matcher(s);
        return m.find() ? m.group(2) : null;
    }
}