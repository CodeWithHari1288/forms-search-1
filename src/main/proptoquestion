import java.nio.file.*;
import java.io.IOException;
import java.util.*;
import java.util.regex.*;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;

public class RenameFromExportBlocks {

    public static void main(String[] args) throws Exception {
        // USAGE:
        //   java RenameFromExportBlocks blocks.txt records.json output.json
        Path blocksPath  = Paths.get(args.length > 0 ? args[0] : "blocks.txt");   // export const ... blocks
        Path recordsPath = Paths.get(args.length > 1 ? args[1] : "records.json"); // JSON array of objects
        Path outputPath  = Paths.get(args.length > 2 ? args[2] : "output.json");

        // 1) Build Prop -> Label/Question map from blocks file
        String blocks = new String(Files.readAllBytes(blocksPath), "UTF-8");
        Map<String,String> propToLabel = parsePropToLabel(blocks); // key: lower(prop) -> label
        if (propToLabel.isEmpty()) {
            System.err.println("No mappings found in export blocks. Need Label/Question and Prop.");
            return;
        }
        System.out.println("Loaded mappings: " + propToLabel.size());

        // 2) Read JSON array (preserve insertion order of keys)
        ObjectMapper om = new ObjectMapper();
        List<LinkedHashMap<String,Object>> rows = om.readValue(
                Files.newBufferedReader(recordsPath),
                new TypeReference<List<LinkedHashMap<String,Object>>>() {}
        );

        // 3) Rename keys per object (top-level only). Unmapped keys stay.
        List<Map<String,Object>> out = new ArrayList<>(rows.size());
        for (LinkedHashMap<String,Object> row : rows) {
            LinkedHashMap<String,Object> renamed = new LinkedHashMap<>();
            for (Map.Entry<String,Object> e : row.entrySet()) {
                String key = e.getKey();
                Object val = e.getValue();
                String label = propToLabel.get(key.toLowerCase(Locale.ROOT));
                String newKey = (label != null && !label.isEmpty()) ? label : key;
                // If two props map to same label in one object, last wins; change policy if needed.
                renamed.put(newKey, val);
            }
            out.add(renamed);
        }

        // 4) Write output JSON
        ObjectWriter writer = om.writer(new DefaultPrettyPrinter());
        writer.writeValue(outputPath.toFile(), out);
        System.out.println("Wrote " + out.size() + " records -> " + outputPath.toAbsolutePath());
    }

    /* ---------------- Parse `export const Name = { ... }` blocks ---------------- */
    private static Map<String,String> parsePropToLabel(String text) {
        Map<String,String> map = new LinkedHashMap<>();

        // Match whole blocks: export const <Key> = { ... }
        Pattern block = Pattern.compile(
            "export\\s+const\\s+[A-Za-z0-9_$]+\\s*=\\s*\\{(.*?)\\}",
            Pattern.CASE_INSENSITIVE | Pattern.DOTALL
        );

        // Inside block: Label / Question and Prop / Property (quoted values)
        Pattern pQuestion = Pattern.compile("\\bQuestion\\b\\s*:\\s*(['\"])(.*?)\\1",
                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Pattern pLabel    = Pattern.compile("\\bLabel\\b\\s*:\\s*(['\"])(.*?)\\1",
                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Pattern pProp     = Pattern.compile("\\bProp(?:erty)?\\b\\s*:\\s*(['\"])(.*?)\\1",
                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);

        Matcher m = block.matcher(text);
        while (m.find()) {
            String body = m.group(1);
            String label = first(pQuestion, body);
            if (label == null) label = first(pLabel, body);
            String prop = first(pProp, body);
            if (label != null && prop != null && !prop.isEmpty()) {
                map.put(prop.trim().toLowerCase(Locale.ROOT), label.trim());
            }
        }
        return map;
    }

    private static String first(Pattern p, String s) {
        Matcher m = p.matcher(s);
        return m.find() ? m.group(2) : null;
    }
}