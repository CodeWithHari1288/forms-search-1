import java.nio.file.*;
import java.io.IOException;
import java.util.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;

public class RenameKeysFromSimpleMappings {

    public static void main(String[] args) throws Exception {
        // USAGE:
        //   java RenameKeysFromSimpleMappings mappings.txt records.json output.json
        Path mappingsPath = Paths.get(args.length > 0 ? args[0] : "mappings.txt");
        Path recordsPath  = Paths.get(args.length > 1 ? args[1] : "records.json");
        Path outputPath   = Paths.get(args.length > 2 ? args[2] : "output.json");

        // 1) Read mappings: "Question: prop" per line
        Map<String, String> propToQuestion = readMappings(mappingsPath);
        if (propToQuestion.isEmpty()) {
            System.err.println("No valid mappings found. Expected lines like: Question1: prop1");
            return;
        }

        // 2) Read JSON array (preserve insertion order)
        ObjectMapper om = new ObjectMapper();
        List<LinkedHashMap<String,Object>> rows = om.readValue(
                Files.newBufferedReader(recordsPath),
                new TypeReference<List<LinkedHashMap<String,Object>>>() {}
        );

        // 3) Rename keys per object (top-level only)
        List<Map<String,Object>> out = new ArrayList<>(rows.size());
        for (LinkedHashMap<String,Object> row : rows) {
            LinkedHashMap<String,Object> renamed = new LinkedHashMap<>();
            for (Map.Entry<String,Object> e : row.entrySet()) {
                String key = e.getKey();
                Object val = e.getValue();
                // Case-insensitive match on prop name
                String q = propToQuestion.get(key.toLowerCase(Locale.ROOT));
                String newKey = (q != null && !q.isEmpty()) ? q : key;
                // If multiple props map to same question, last one wins; change if needed.
                renamed.put(newKey, val);
            }
            out.add(renamed);
        }

        // 4) Write output JSON
        ObjectWriter writer = om.writer(new DefaultPrettyPrinter());
        writer.writeValue(outputPath.toFile(), out);
        System.out.println("Wrote " + out.size() + " records -> " + outputPath.toAbsolutePath());
    }

    private static Map<String,String> readMappings(Path mappingsPath) throws IOException {
        // map: lower(prop) -> question
        Map<String,String> m = new LinkedHashMap<>();
        List<String> lines = Files.readAllLines(mappingsPath);
        for (String raw : lines) {
            String line = raw.trim();
            if (line.isEmpty()) continue;
            // allow comments with // or #
            if (line.startsWith("//") || line.startsWith("#")) continue;

            int idx = line.indexOf(':');
            if (idx < 0) continue;

            String question = line.substring(0, idx).trim();
            String prop     = line.substring(idx + 1).trim();

            if (!question.isEmpty() && !prop.isEmpty()) {
                m.put(prop.toLowerCase(Locale.ROOT), question);
            }
        }
        return m;
    }
}