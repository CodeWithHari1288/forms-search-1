// JsonCatalogExporter.java
// Java 8, single-file, OpenCSV + Jackson.
// Usage examples:
//   java -cp <your-fat-jar>.jar JsonCatalogExporter \
//     --json data/formA.json --template_csv data/template.csv --out_dir data/out --id_pointer /form_id
//   java -cp <your-fat-jar>.jar JsonCatalogExporter \
//     --json data/jsons     --template_csv data/template.csv --out_dir data/out
//
// Behavior:
// - If --json points to a directory: process every *.json file (one CSV per file or per element if root is array).
// - If --json points to a file:
//     * If root is an array: writes one CSV per element (basename_0.csv, basename_1.csv, ... or using --id_pointer).
//     * Else: writes one CSV for the object.

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.MissingNode;
import com.opencsv.CSVReaderHeaderAware;
import com.opencsv.CSVWriter;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.*;

public class JsonCatalogExporter {

  // ---------- Config ----------
  private static final ObjectMapper MAPPER = new ObjectMapper(new JsonFactory());

  // ---------- Main ----------
  public static void main(String[] args) throws Exception {
    Map<String,String> arg = parseArgs(args);

    String jsonPath    = required(arg, "--json");          // file OR directory
    String templateCsv = required(arg, "--template_csv");  // your catalog template
    String outDir      = required(arg, "--out_dir");       // where CSVs are written
    String idPointer   = arg.get("--id_pointer");          // optional: e.g., /form_id

    // Load template once
    List<Map<String,String>> templateRows = readTemplateCsv(templateCsv);
    List<String> header = inferHeader(templateRows);
    if (!header.contains("value")) header.add("value");
    if (!header.contains("found")) header.add("found");

    File p = new File(jsonPath);
    if (p.isDirectory()) {
      // Process every *.json inside the directory
      File[] files = p.listFiles(new FilenameFilter() {
        public boolean accept(File d, String name) { return name.toLowerCase().endsWith(".json"); }
      });
      if (files == null) files = new File[0];
      ensureDir(new File(outDir));

      for (File f : files) {
        JsonNode doc = readJson(f.getAbsolutePath());
        if (doc != null && doc.isArray()) {
          // One CSV per element
          for (int i = 0; i < doc.size(); i++) {
            JsonNode one = doc.get(i);
            String baseName = stripExt(f.getName());
            String suffix = makeSuffix(one, idPointer, i);
            String outCsv = Paths.get(outDir, baseName + suffix + ".csv").toString();
            List<Map<String,String>> filled = processRows(one, templateRows);
            writeCsv(outCsv, header, filled);
            System.out.println("Wrote " + outCsv);
          }
        } else {
          // Single object
          String baseName = stripExt(f.getName());
          String suffix = makeSuffix(doc, idPointer, -1);
          String outCsv = Paths.get(outDir, baseName + suffix + ".csv").toString();
          List<Map<String,String>> filled = processRows(doc, templateRows);
          writeCsv(outCsv, header, filled);
          System.out.println("Wrote " + outCsv);
        }
      }
      return;
    }

    // Single file path
    JsonNode root = readJson(jsonPath);
    ensureDir(new File(outDir));
    String baseName = stripExt(new File(jsonPath).getName());

    if (root != null && root.isArray()) {
      for (int i = 0; i < root.size(); i++) {
        JsonNode one = root.get(i);
        String suffix = makeSuffix(one, idPointer, i);
        String outCsv = Paths.get(outDir, baseName + suffix + ".csv").toString();
        List<Map<String,String>> filled = processRows(one, templateRows);
        writeCsv(outCsv, header, filled);
        System.out.println("Wrote " + outCsv);
      }
    } else {
      String suffix = makeSuffix(root, idPointer, -1);
      String outCsv = Paths.get(outDir, baseName + suffix + ".csv").toString();
      List<Map<String,String>> filled = processRows(root, templateRows);
      writeCsv(outCsv, header, filled);
      System.out.println("Wrote " + outCsv);
    }
  }

  // ---------- Core row processing (template → filled rows) ----------
  /** Priority: pointer → pattern_path with * → pattern_path exact → json_property_name */
  public static List<Map<String,String>> processRows(JsonNode doc, List<Map<String,String>> templateRows) {
    List<Map<String,String>> out = new ArrayList<Map<String,String>>();
    for (Map<String,String> row : templateRows) {
      Map<String,String> base = new LinkedHashMap<String,String>(row);

      String pointer  = trim(row.get("pointer"));
      String pattern  = trim(row.get("pattern_path"));
      String jsonProp = trim(row.get("json_property_name"));

      // 1) pointer (exact, no *)
      if (!isEmpty(pointer) && pointer.indexOf('*') < 0) {
        JsonNode val = atPointer(doc, pointer);
        boolean found = !isMissing(val);
        base.put("value", stringify(val));
        base.put("found", found ? "1" : "0");
        out.add(base);
        continue;
      }

      // 2) pattern with *
      if (!isEmpty(pattern) && pattern.indexOf('*') >= 0) {
        List<String> concrete = expandPattern(doc, pattern);
        if (concrete.isEmpty()) {
          Map<String,String> nf = new LinkedHashMap<String,String>(base);
          nf.put("value", "");
          nf.put("found", "0");
          out.add(nf);
        } else {
          for (String cptr : concrete) {
            Map<String,String> r = new LinkedHashMap<String,String>(base);
            JsonNode val = atPointer(doc, cptr);
            boolean found = !isMissing(val);
            r.put("pointer", cptr);
            // Try to auto-fill row_id from parent object if present
            if (isEmpty(r.get("row_id"))) {
              String rid = extractRowIdFromParent(doc, cptr);
              if (rid != null) r.put("row_id", rid);
            }
            r.put("value", stringify(val));
            r.put("found", found ? "1" : "0");
            out.add(r);
          }
        }
        continue;
      }

      // 3) pattern exact (no *)
      if (!isEmpty(pattern)) {
        JsonNode val = atPointer(doc, pattern);
        boolean found = !isMissing(val);
        base.put("pointer", pattern);
        base.put("value", stringify(val));
        base.put("found", found ? "1" : "0");
        out.add(base);
        continue;
      }

      // 4) json_property_name lookup (first hit anywhere)
      if (!isEmpty(jsonProp)) {
        KeyHit hit = findFirstByKey(doc, jsonProp);
        if (hit != null) {
          base.put("pointer", hit.pointer);
          base.put("value", stringify(hit.value));
          base.put("found", "1");
          out.add(base);
          continue;
        }
      }

      // 5) not found
      base.put("value", "");
      base.put("found", "0");
      out.add(base);
    }
    return out;
  }

  // ---------- JSON helpers ----------
  private static JsonNode readJson(String path) throws IOException {
    InputStream in = new FileInputStream(path);
    try { return MAPPER.readTree(in); }
    finally { try { in.close(); } catch (Exception ignore) {} }
  }

  /** RFC6901 pointer read with Jackson. */
  public static JsonNode atPointer(JsonNode doc, String pointer) {
    try {
      JsonPointer jp = JsonPointer.compile(pointer);
      JsonNode n = doc.at(jp);
      return (n == null) ? MissingNode.getInstance() : n;
    } catch (IllegalArgumentException e) {
      return MissingNode.getInstance();
    }
  }

  private static boolean isMissing(JsonNode n) {
    return n == null || n.isMissingNode() || n.isNull();
  }

  private static String stringify(JsonNode n) {
    if (isMissing(n)) return "";
    if (n.isValueNode()) return n.asText();
    try { return MAPPER.writeValueAsString(n); }
    catch (Exception e) { return n.toString(); }
  }

  private static String parentPointerOf(String ptr) {
    if (ptr == null || ptr.length() == 0 || "/".equals(ptr)) return null;
    int idx = ptr.lastIndexOf('/');
    if (idx <= 0) return "/";
    return ptr.substring(0, idx);
  }

  private static String extractRowIdFromParent(JsonNode doc, String concretePtr) {
    String parentPtr = parentPointerOf(concretePtr);
    if (parentPtr == null) return null;
    JsonNode parent = atPointer(doc, parentPtr);
    if (parent != null && parent.isObject()) {
      JsonNode rid = parent.get("row_id");
      if (rid != null && (rid.isTextual() || rid.isNumber())) return rid.asText();
    }
    return null;
  }

  /** Expand a pattern containing exactly one '*' into concrete pointers. */
  private static List<String> expandPattern(JsonNode doc, String patternPath) {
    if (isEmpty(patternPath) || patternPath.indexOf('*') < 0) {
      List<String> single = new ArrayList<String>(1);
      single.add(patternPath);
      return single;
    }
    String[] parts = splitAndKeepOrder(patternPath);
    List<String> out = new ArrayList<String>();
    walkPattern(doc, parts, 0, new ArrayList<String>(), out);
    return out;
  }

  private static void walkPattern(JsonNode node, String[] parts, int i, List<String> acc, List<String> out) {
    if (i == parts.length) {
      out.add("/" + joinSlash(acc));
      return;
    }
    String part = parts[i];

    if ("*".equals(part)) {
      if (node != null && node.isArray()) {
        for (int idx = 0; idx < node.size(); idx++) {
          JsonNode child = node.get(idx);
          List<String> next = new ArrayList<String>(acc);
          next.add(String.valueOf(idx));
          walkPattern(child, parts, i + 1, next, out);
        }
      }
      return;
    }

    if (node == null || node.isMissingNode() || node.isNull()) return;

    if (node.isObject()) {
      JsonNode child = node.get(part);
      if (child != null) {
        List<String> next = new ArrayList<String>(acc);
        next.add(part);
        walkPattern(child, parts, i + 1, next, out);
      }
    } else if (node.isArray()) {
      try {
        int idx = Integer.parseInt(part);
        if (idx >= 0 && idx < node.size()) {
          JsonNode child = node.get(idx);
          List<String> next = new ArrayList<String>(acc);
          next.add(part);
          walkPattern(child, parts, i + 1, next, out);
        }
      } catch (NumberFormatException ignore) { }
    }
  }

  /** DFS to find first occurrence of a key anywhere in the JSON tree. */
  private static KeyHit findFirstByKey(JsonNode root, String key) {
    Deque<PathNode> stack = new ArrayDeque<PathNode>();
    stack.push(new PathNode(root, new ArrayList<String>()));

    while (!stack.isEmpty()) {
      PathNode cur = stack.pop();
      JsonNode n = cur.node;
      List<String> p = cur.path;

      if (n == null || n.isMissingNode() || n.isNull()) continue;

      if (n.isObject()) {
        JsonNode direct = n.get(key);
        if (direct != null) {
          List<String> path = new ArrayList<String>(p);
          path.add(key);
          return new KeyHit("/" + joinSlash(path), direct);
        }
        Iterator<String> it = n.fieldNames();
        while (it.hasNext()) {
          String k = it.next();
          JsonNode child = n.get(k);
          List<String> np = new ArrayList<String>(p);
          np.add(k);
          stack.push(new PathNode(child, np));
        }
      } else if (n.isArray()) {
        for (int i = 0; i < n.size(); i++) {
          JsonNode child = n.get(i);
          List<String> np = new ArrayList<String>(p);
          np.add(String.valueOf(i));
          stack.push(new PathNode(child, np));
        }
      }
    }
    return null;
  }

  // ---------- CSV helpers (OpenCSV) ----------
  public static List<Map<String,String>> readTemplateCsv(String path) throws IOException {
    InputStreamReader in = new InputStreamReader(new FileInputStream(path), StandardCharsets.UTF_8);
    CSVReaderHeaderAware reader = new CSVReaderHeaderAware(in);
    try {
      List<Map<String,String>> rows = new ArrayList<Map<String,String>>();
      Map<String,String> map;
      while ((map = reader.readMap()) != null) {
        rows.add(new LinkedHashMap<String,String>(map)); // keep column order
      }
      return rows;
    } finally {
      try { reader.close(); } catch (Exception ignore) {}
      try { in.close(); } catch (Exception ignore) {}
    }
  }

  public static void writeCsv(String path, List<String> header, List<Map<String,String>> rows) throws IOException {
    File f = new File(path);
    ensureDir(f.getParentFile());

    OutputStreamWriter w = new OutputStreamWriter(new FileOutputStream(f), StandardCharsets.UTF_8);
    CSVWriter writer = new CSVWriter(w,
        CSVWriter.DEFAULT_SEPARATOR,
        CSVWriter.DEFAULT_QUOTE_CHARACTER,
        CSVWriter.DEFAULT_ESCAPE_CHARACTER,
        CSVWriter.DEFAULT_LINE_END);
    try {
      writer.writeNext(header.toArray(new String[header.size()]));
      for (Map<String,String> row : rows) {
        String[] rec = new String[header.size()];
        for (int i = 0; i < header.size(); i++) {
          String h = header.get(i);
          String v = row.containsKey(h) ? row.get(h) : "";
          rec[i] = (v == null) ? "" : v;
        }
        writer.writeNext(rec, false);
      }
    } finally {
      try { writer.close(); } catch (Exception ignore) {}
      try { w.close(); } catch (Exception ignore) {}
    }
  }

  public static List<String> inferHeader(List<Map<String,String>> rows) {
    if (rows.isEmpty()) return new ArrayList<String>();
    return new ArrayList<String>(rows.get(0).keySet()); // preserve CSV column order
  }

  // ---------- Small helper classes (Java 8) ----------
  private static final class KeyHit {
    final String pointer;
    final JsonNode value;
    KeyHit(String pointer, JsonNode value) { this.pointer = pointer; this.value = value; }
  }
  private static final class PathNode {
    final JsonNode node;
    final List<String> path;
    PathNode(JsonNode node, List<String> path) { this.node = node; this.path = path; }
  }

  // ---------- Util ----------
  private static Map<String,String> parseArgs(String[] args) {
    Map<String,String> m = new HashMap<String,String>();
    for (int i = 0; i < args.length - 1; i += 2) m.put(args[i], args[i+1]);
    return m;
  }
  private static String required(Map<String,String> m, String key) {
    String v = m.get(key);
    if (v == null) throw new IllegalArgumentException("Missing argument: " + key);
    return v;
  }
  private static boolean isEmpty(String s) { return s == null || s.trim().isEmpty(); }
  private static String trim(String s) { return (s == null) ? "" : s.trim(); }
  private static void ensureDir(File d) { if (d != null && !d.exists()) d.mkdirs(); }
  private static String[] splitAndKeepOrder(String patternPath) {
    String[] raw = patternPath.split("/");
    List<String> parts = new ArrayList<String>();
    for (int i = 0; i < raw.length; i++) {
      if (raw[i] != null && raw[i].length() > 0) parts.add(raw[i]);
    }
    return parts.toArray(new String[parts.size()]);
  }
  private static String joinSlash(List<String> parts) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < parts.size(); i++) {
      if (i > 0) sb.append("/");
      sb.append(parts.get(i));
    }
    return sb.toString();
  }
  private static String stripExt(String name) {
    int i = name.lastIndexOf('.');
    return (i > 0) ? name.substring(0, i) : name;
  }
  private static String sanitize(String s) {
    return s.replaceAll("[^A-Za-z0-9._-]", "_");
  }
  private static String makeSuffix(JsonNode doc, String idPointer, int idxFallback) {
    if (idPointer != null && idPointer.length() > 0) {
      JsonNode id = atPointer(doc, idPointer);
      if (id != null && !id.isMissingNode() && !id.isNull() && id.isValueNode()) {
        String s = id.asText().trim();
        if (s.length() > 0) return "_" + sanitize(s);
      }
    }
    if (idxFallback >= 0) return "_" + idxFallback;
    return "";
  }
}