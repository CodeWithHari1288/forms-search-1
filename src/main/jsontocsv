// JsonArrayToCsvByPropTemplate.java
// Reads a template CSV with a "prop" column containing JSON property paths.
// For each JSON object in the array, creates one CSV file where
// - label/value columns are written.
// - Arrays expand to multiple rows (each array element = one row).

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JsonArrayToCsvByPropTemplate {

    private static final ObjectMapper MAPPER = new ObjectMapper();
    private static final Pattern BRACKET = Pattern.compile("\\[([^\\]]*)\\]");

    public static void main(String[] args) throws Exception {
        if (args.length < 3) {
            System.err.println("Usage: java JsonArrayToCsvByPropTemplate <templateCsvPath> <jsonArrayPath> <outputDir>");
            System.exit(1);
        }
        Path templateCsv = Paths.get(args[0]);
        Path jsonArray   = Paths.get(args[1]);
        Path outDir      = Paths.get(args[2]);
        Files.createDirectories(outDir);

        // Read template
        List<Map<String, String>> template = readTemplate(templateCsv);

        // Read JSON array
        List<JsonNode> items = MAPPER.readValue(
                Files.newBufferedReader(jsonArray),
                new TypeReference<List<JsonNode>>() {}
        );

        int index = 1;
        for (JsonNode obj : items) {
            String fileName = obj.hasNonNull("form_id")
                    ? obj.get("form_id").asText()
                    : "record_" + index;
            Path outFile = outDir.resolve(fileName + ".csv");

            try (Writer writer = Files.newBufferedWriter(outFile);
                 CSVWriter csv = new CSVWriter(writer)) {

                csv.writeNext(new String[]{"label", "value"}, false);

                for (Map<String, String> row : template) {
                    String prop = row.get("prop");
                    String label = row.getOrDefault("label", prop);
                    List<String> vals = resolveValues(obj, prop);
                    if (vals.isEmpty()) vals = Collections.singletonList("");

                    for (String v : vals) {
                        csv.writeNext(new String[]{label, v}, false);
                    }
                }
            }
            System.out.println("âœ… Wrote: " + outFile);
            index++;
        }
    }

    // --- Template reader (expects columns: prop,label) ---
    private static List<Map<String, String>> readTemplate(Path path) throws IOException {
        try (Reader r = Files.newBufferedReader(path);
             CSVReader csv = new CSVReader(r)) {
            String[] headers = csv.readNext();
            if (headers == null) throw new IOException("Template CSV is empty");
            List<Map<String, String>> rows = new ArrayList<>();
            String[] row;
            while ((row = csv.readNext()) != null) {
                Map<String, String> map = new HashMap<>();
                for (int i = 0; i < headers.length && i < row.length; i++) {
                    map.put(headers[i].trim().toLowerCase(), row[i].trim());
                }
                rows.add(map);
            }
            return rows;
        }
    }

    // --- Resolve JSON path (supports dotted paths, [*], [0]) ---
    private static List<String> resolveValues(JsonNode root, String path) {
        if (root == null || root.isNull() || path == null || path.isEmpty()) return List.of("");
        String[] segments = path.split("\\.");
        List<JsonNode> current = new ArrayList<>();
        current.add(root);

        for (String seg : segments) {
            if (seg.isEmpty()) continue;
            List<JsonNode> next = new ArrayList<>();
            for (JsonNode node : current) {
                if (node == null || node.isNull()) continue;
                List<ArrayAccess> accs = parseSegment(seg);
                List<JsonNode> nodesAfter = List.of(node);

                for (ArrayAccess acc : accs) {
                    List<JsonNode> tmp = new ArrayList<>();
                    for (JsonNode n : nodesAfter) {
                        JsonNode base = n;
                        if (acc.field != null && !acc.field.isEmpty()) base = base.get(acc.field);
                        if (base == null || base.isNull()) continue;

                        if (acc.kind == ArrayAccess.Kind.NONE) {
                            tmp.add(base);
                        } else if (acc.kind == ArrayAccess.Kind.INDEX) {
                            if (base.isArray() && acc.index != null && acc.index >= 0 && acc.index < base.size()) {
                                tmp.add(base.get(acc.index));
                            }
                        } else if (acc.kind == ArrayAccess.Kind.WILDCARD) {
                            if (base.isArray()) {
                                for (JsonNode el : base) tmp.add(el);
                            }
                        }
                    }
                    nodesAfter = tmp;
                }
                next.addAll(nodesAfter);
            }
            current = next;
            if (current.isEmpty()) break;
        }

        if (current.isEmpty()) return List.of("");
        List<String> out = new ArrayList<>();
        for (JsonNode n : current) out.add(stringifyNode(n));
        return out;
    }

    private static List<ArrayAccess> parseSegment(String seg) {
        List<ArrayAccess> list = new ArrayList<>();
        String field = null;
        int i = seg.indexOf('[');
        if (i < 0) {
            Integer maybeIdx = tryParseInt(seg);
            if (maybeIdx != null) list.add(new ArrayAccess(null, ArrayAccess.Kind.INDEX, maybeIdx));
            else list.add(new ArrayAccess(seg, ArrayAccess.Kind.NONE, null));
        } else {
            field = seg.substring(0, i);
            if (!field.isEmpty()) list.add(new ArrayAccess(field, ArrayAccess.Kind.NONE, null));
            Matcher m = BRACKET.matcher(seg.substring(i));
            while (m.find()) {
                String token = m.group(1).trim();
                if ("*".equals(token)) list.add(new ArrayAccess(null, ArrayAccess.Kind.WILDCARD, null));
                else {
                    Integer idx = tryParseInt(token);
                    if (idx != null) list.add(new ArrayAccess(null, ArrayAccess.Kind.INDEX, idx));
                }
            }
        }
        return list;
    }

    private static Integer tryParseInt(String s) {
        try { return Integer.parseInt(s); } catch (Exception e) { return null; }
    }

    private static String stringifyNode(JsonNode n) {
        if (n == null || n.isNull()) return "";
        if (n.isTextual()) return n.asText();
        if (n.isNumber())  return n.numberValue().toString();
        if (n.isBoolean()) return String.valueOf(n.booleanValue());
        try { return MAPPER.writeValueAsString(n); } catch (Exception e) { return n.toString(); }
    }

    private static class ArrayAccess {
        enum Kind { NONE, INDEX, WILDCARD }
        final String field;
        final Kind kind;
        final Integer index;
        ArrayAccess(String field, Kind kind, Integer index) {
            this.field = field;
            this.kind = kind;
            this.index = index;
        }
    }
}