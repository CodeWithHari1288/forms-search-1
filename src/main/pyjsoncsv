#!/usr/bin/env python3
# JSON → CSV by matching template 'property' (or 'prop') to JSON keys anywhere.
# Emits a row for EVERY matching key, even if its value is an object or array.
#
# Usage:
#   python json_to_csv_property_keys.py --json input.json --template template.csv --out out.csv
#   python json_to_csv_property_keys.py --json folder/ --template template.csv --out_dir out/
#   (optional) --id_pointer /path/to/id   # to suffix filenames when splitting/batching
import json, csv, sys, os
from typing import Any, List, Dict, Tuple

def esc_token(s): return s.replace("~","~0").replace("/","~1")  # RFC6901
def pointer_from(path: List[str]) -> str: return "/" + "/".join(esc_token(p) for p in path)

def index_path(path: List[str]) -> str:
    # e.g. ["applicants","0","addresses","1","city"] -> "applicants=0>addresses=1"
    out = []
    for i, seg in enumerate(path):
        if seg.isdigit():
            parent = path[i-1] if i>0 else ""
            out.append((parent + "=" + seg) if parent else seg)
    return ">".join(out)

def walk_keys(doc: Any, base: List[str]=[]) -> Tuple[List[str], Any]:
    """
    Yield (path_to_key, value_at_key) for EVERY dict key (not just leaves).
    Recurse into children so nested keys are discovered too.
    """
    if isinstance(doc, dict):
        for k, v in doc.items():
            path = base + [str(k)]
            yield path, v                # <-- emit EVERY key match, regardless of value type
            for p,v2 in walk_keys(v, path):
                yield p, v2
    elif isinstance(doc, list):
        for i, v in enumerate(doc):
            for p,v2 in walk_keys(v, base + [str(i)]):
                yield p, v2
    else:
        # scalar with no key at this level → nothing to emit
        return

def load_template(path: str) -> List[Dict[str,str]]:
    rows = []
    with open(path, newline="", encoding="utf-8") as f:
        r = csv.DictReader(f)
        for row in r:
            prop = (row.get("property") if "property" in row else row.get("prop","")) or ""
            row["_property_norm"] = prop.strip().lower()
            aliases = (row.get("aliases","") or "").split("|")
            row["_aliases_norm"] = [a.strip().lower() for a in aliases if a.strip()]
            row["_path_prefix"]  = (row.get("path_prefix","") or "").strip()
            rows.append(row)
    return rows, r.fieldnames or []

def match_key(path: List[str], tpl: Dict[str,str], case_insensitive=True) -> bool:
    key = (path[-1] if path else "").strip()
    if case_insensitive:
        key_cmp = key.lower()
        if key_cmp == tpl["_property_norm"]: return True
        if key_cmp in tpl["_aliases_norm"]:  return True
    else:
        if key == tpl["_property_norm"]:     return True
        if key in tpl["_aliases_norm"]:      return True
    return False

def prefix_ok(path: List[str], prefix: str) -> bool:
    if not prefix: return True
    return pointer_from(path).startswith(prefix)

def fill_rows_for_doc(doc: Any, template_csv: str, case_insensitive=True) -> (List[str], List[Dict[str,str]]):
    template, tpl_headers = load_template(template_csv)

    # Build output header: all template columns + computed
    header = list(tpl_headers) if tpl_headers else []
    for extra in ["value","json_pointer","index_path"]:
        if extra not in header: header.append(extra)

    # Pre-enumerate EVERY key in JSON
    hits_pool = list(walk_keys(doc))  # [(path_to_key, value_at_key), ...]

    out_rows: List[Dict[str,str]] = []
    for tpl in template:
        prefix = tpl["_path_prefix"]
        matches = []
        for path, val in hits_pool:
            if not match_key(path, tpl, case_insensitive): continue
            if not prefix_ok(path, prefix):                continue
            matches.append((path, val))

        if not matches:
            row = dict(tpl); row["value"]=""; row["json_pointer"]=""; row["index_path"]=""
            out_rows.append(row)
        else:
            for path, val in matches:
                row = dict(tpl)
                if isinstance(val, (str,int,float,bool)) or val is None:
                    row["value"] = val
                else:
                    row["value"] = json.dumps(val, ensure_ascii=False)  # serialize arrays/objects
                row["json_pointer"] = pointer_from(path)
                row["index_path"]   = index_path(path)
                out_rows.append(row)

    return header, out_rows

def write_csv(path: str, header: List[str], rows: List[Dict[str,str]]):
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=header, extrasaction="ignore")
        w.writeheader()
        for r in rows: w.writerow(r)

def sanitize(s: str) -> str:
    return "".join(ch if (ch.isalnum() or ch in "._-") else "_" for ch in s)

def get_pointer(doc: Any, pointer: str):
    if not pointer or pointer == "/": return doc
    parts = pointer.split("/")[1:]
    cur = doc
    for raw in parts:
        key = raw.replace("~1","/").replace("~0","~")
        if isinstance(cur, list):
            try: idx = int(key)
            except: return None
            if idx<0 or idx>=len(cur): return None
            cur = cur[idx]
        elif isinstance(cur, dict):
            if key not in cur: return None
            cur = cur[key]
        else:
            return None
    return cur

def main(argv):
    # flags: --json <file|dir>, --template <csv>, --out <csv>, --out_dir <dir>, [--id_pointer /path], [--case_insensitive true|false]
    args = {}
    i=0
    while i < len(argv):
        if argv[i].startswith("--"):
            k = argv[i]; v = None
            if i+1<len(argv) and not argv[i+1].startswith("--"):
                v = argv[i+1]; i+=1
            args[k]=v
        i+=1

    in_path    = args.get("--json")
    template   = args.get("--template")
    out_csv    = args.get("--out")
    out_dir    = args.get("--out_dir")
    id_pointer = args.get("--id_pointer")
    ci_flag    = args.get("--case_insensitive","true").lower() != "false"

    if not in_path or not template:
        sys.exit("Usage:\n  --json <file|dir> --template <template.csv> [--out <file.csv>] [--out_dir <dir>] [--id_pointer /path] [--case_insensitive true|false]")

    if os.path.isdir(in_path):
        if not out_dir: sys.exit("When --json is a directory, provide --out_dir.")
        os.makedirs(out_dir, exist_ok=True)
        for name in os.listdir(in_path):
            if not name.lower().endswith(".json"): continue
            p = os.path.join(in_path, name)
            with open(p,"r",encoding="utf-8") as f: doc = json.load(f)
            base = os.path.splitext(name)[0]

            if isinstance(doc, list):
                for idx, elem in enumerate(doc):
                    suffix = f"_{idx}"
                    if id_pointer:
                        v = get_pointer(elem, id_pointer)
                        if isinstance(v,(str,int,float,bool)): 
                            s=str(v).strip()
                            if s: suffix = "_"+sanitize(s)
                    header, rows = fill_rows_for_doc(elem, template, ci_flag)
                    write_csv(os.path.join(out_dir, f"{base}{suffix}.csv"), header, rows)
            else:
                suffix = ""
                if id_pointer:
                    v = get_pointer(doc, id_pointer)
                    if isinstance(v,(str,int,float,bool)): 
                        s=str(v).strip()
                        if s: suffix = "_"+sanitize(s)
                header, rows = fill_rows_for_doc(doc, template, ci_flag)
                write_csv(os.path.join(out_dir, f"{base}{suffix}.csv"), header, rows)
    else:
        with open(in_path,"r",encoding="utf-8") as f: doc = json.load(f)
        if isinstance(doc, list):
            if not out_csv and not out_dir:
                sys.exit("Root array: provide --out (base name) or --out_dir.")
            base_dir = (out_dir or os.path.dirname(out_csv) or ".")
            base_fn  = os.path.splitext(os.path.basename(out_csv or "out.csv"))[0]
            os.makedirs(base_dir, exist_ok=True)
            for idx, elem in enumerate(doc):
                suffix = f"_{idx}"
                if id_pointer:
                    v = get_pointer(elem, id_pointer)
                    if isinstance(v,(str,int,float,bool)): 
                        s=str(v).strip()
                        if s: suffix = "_"+sanitize(s)
                header, rows = fill_rows_for_doc(elem, template, ci_flag)
                write_csv(os.path.join(base_dir, f"{base_fn}{suffix}.csv"), header, rows)
        else:
            if not out_csv:
                sys.exit("Provide --out <file.csv> when --json is a file.")
            header, rows = fill_rows_for_doc(doc, template, ci_flag)
            write_csv(out_csv, header, rows)

if __name__ == "__main__":
    main(sys.argv[1:])