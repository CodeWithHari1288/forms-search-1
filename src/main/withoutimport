{
  "name": "subapp-copilot",
  "private": true,
  "version": "1.0.0",
  "dependencies": {
    "@copilotkit/react-core": "^1.8.12",
    "@copilotkit/react-ui": "^1.8.12",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "PORT=3001 react-scripts start"
  }
}




import React from "react";
import { CopilotKitProvider } from "@copilotkit/react-core";
import { CopilotChat /* or CopilotSidebar */ } from "@copilotkit/react-ui";

export default function App() {
  return (
    <CopilotKitProvider runtimeUrl="http://localhost:8000/copilot">
      <div style={{ height: "100vh", display: "flex", flexDirection: "column" }}>
        <h2 style={{ margin: 16, fontFamily: "system-ui, sans-serif" }}>Copilot</h2>
        <div style={{ flex: 1, minHeight: 0, borderTop: "1px solid #e5e7eb" }}>
          <CopilotChat placeholder="Ask me anything…" />
        </div>
      </div>
    </CopilotKitProvider>
  );
}





import React from "react";
import SubappFrame from "./SubappFrame";

export default function App() {
  return (
    <div style={{ padding: 24, minHeight: "120vh" }}>
      <h1>Main App (React 14)</h1>
      <p>Sub-app runs on its own port and is shown below in an iframe.</p>

      <SubappFrame src="http://localhost:3001" height={600} width={420} />
    </div>
  );
}




/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}"
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}





import React, { useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";

export default function SubappDock({
  src = "http://localhost:3001",     // sub-app URL
  width = 420,
  height = 600,
  right = 20,
  bottom = 20,
  defaultOpen = true,
  zIndex = 2147483646,               // above most UI
}) {
  const [open, setOpen] = useState(defaultOpen);
  const mountRef = useRef(null);

  // Create a host element attached to <body>
  useEffect(() => {
    const host = document.createElement("div");
    // Make sure nothing inherited affects it
    host.style.all = "initial";
    host.style.position = "fixed";
    host.style.right = `${right}px`;
    host.style.bottom = `${bottom}px`;
    host.style.width = `${width}px`;
    host.style.height = `${height}px`;
    host.style.border = "1px solid #e5e7eb";
    host.style.borderRadius = "12px";
    host.style.overflow = "hidden";
    host.style.background = "#fff";
    host.style.boxShadow = "0 16px 48px rgba(0,0,0,0.18)";
    host.style.zIndex = String(zIndex);
    host.style.transition = "transform 160ms ease, opacity 160ms ease";
    host.style.transform = open ? "translateY(0)" : "translateY(12px)";
    host.style.opacity = open ? "1" : "0";
    host.style.pointerEvents = open ? "auto" : "none";
    // Respect mobile safe areas
    host.style.right = `max(${right}px, env(safe-area-inset-right))`;
    host.style.bottom = `max(${bottom}px, env(safe-area-inset-bottom))`;

    document.body.appendChild(host);
    mountRef.current = host;
    return () => {
      try { document.body.removeChild(host); } catch {}
    };
  }, [right, bottom, width, height, zIndex, open]);

  // Toggle button (also in a portal so it’s fixed to viewport)
  const toggleBtn = (
    <button
      onClick={() => setOpen(v => !v)}
      style={{
        position: "fixed",
        right: `max(${right}px, env(safe-area-inset-right))`,
        bottom: open ? `calc(${bottom}px + ${height}px + 12px)` : `max(${bottom}px, env(safe-area-inset-bottom))`,
        zIndex: zIndex + 1,
        border: "1px solid #e5e7eb",
        background: "#111827",
        color: "#fff",
        padding: "10px 14px",
        borderRadius: 999,
        boxShadow: "0 6px 24px rgba(0,0,0,0.15)",
        cursor: "pointer",
        fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, sans-serif",
      }}
      aria-expanded={open}
      aria-controls="copilot-iframe"
      title={open ? "Hide Copilot" : "Open Copilot"}
    >
      {open ? "Close Copilot" : "Open Copilot"}
    </button>
  );

  const iframeEl = mountRef.current ? createPortal(
    <iframe
      id="copilot-iframe"
      title="copilot"
      src={src}
      style={{ width: "100%", height: "100%", border: "none", display: "block" }}
    />,
    mountRef.current
  ) : null;

  return (
    <>
      {toggleBtn}
      {iframeEl}
    </>
  );
}





import React from "react";
import SubappDock from "./SubappDock";

export default function App() {
  return (
    <div style={{ minHeight: "200vh", padding: 24 }}>
      <h1>Main App (React 14)</h1>
      <p>Scroll around; the Copilot sub-app stays bottom-right.</p>

      <SubappDock
        src="http://localhost:3001"   // CRA/Vite dev server for sub-app
        width={420}
        height={600}
        right={20}
        bottom={20}
        defaultOpen={true}
      />
    </div>
  );
}








import React, { useEffect, useLayoutEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";

export default function SubappDock({
  src = "http://localhost:3001",  // sub-app URL
  width = 420,
  height = 600,
  right = 20,
  bottom = 20,
  defaultOpen = true,
  zIndex = 2147483646,
  forceReloadOnOpen = false,       // set true if you still see blanks on reopen
}) {
  const [open, setOpen] = useState(defaultOpen);
  const hostRef = useRef(null);
  const iframeRef = useRef(null);

  // Create the host div ONCE and attach to <body>
  useLayoutEffect(() => {
    const host = document.createElement("div");
    host.id = "copilot-dock-host";
    // isolate from page CSS
    host.style.all = "initial";
    host.style.position = "fixed";
    host.style.right = `max(${right}px, env(safe-area-inset-right))`;
    host.style.bottom = `max(${bottom}px, env(safe-area-inset-bottom))`;
    host.style.width = `${width}px`;
    host.style.height = `${height}px`;
    host.style.border = "1px solid #e5e7eb";
    host.style.borderRadius = "12px";
    host.style.overflow = "hidden";
    host.style.background = "#fff";
    host.style.boxShadow = "0 16px 48px rgba(0,0,0,0.18)";
    host.style.zIndex = String(zIndex);
    host.style.transition = "transform 160ms ease, opacity 160ms ease";
    document.body.appendChild(host);
    hostRef.current = host;

    return () => {
      // remove host only when component unmounts for good
      try { document.body.removeChild(host); } catch {}
      hostRef.current = null;
    };
  }, [right, bottom, width, height, zIndex]);

  // Only toggle visibility; do NOT unmount iframe
  useEffect(() => {
    if (!hostRef.current) return;
    const host = hostRef.current;
    host.style.transform = open ? "translateY(0)" : "translateY(12px)";
    host.style.opacity = open ? "1" : "0";
    host.style.pointerEvents = open ? "auto" : "none";

    // Optional: if reopening and iframe appears blank, force a reload
    if (open && forceReloadOnOpen && iframeRef.current) {
      try {
        // If the frame has no document yet or blanked out, reassign src
        const win = iframeRef.current.contentWindow;
        if (!win || !win.document || win.document.readyState === "uninitialized") {
          iframeRef.current.src = iframeRef.current.src;
        }
      } catch {
        // cross-origin read can throw in some setups; safe to ignore
        iframeRef.current.src = iframeRef.current.src;
      }
    }
  }, [open, forceReloadOnOpen]);

  // Toggle button rendered as a separate fixed element
  const toggleBtn = (
    <button
      onClick={() => setOpen(v => !v)}
      style={{
        position: "fixed",
        right: `max(${right}px, env(safe-area-inset-right))`,
        bottom: open ? `calc(${bottom}px + ${height}px + 12px)` : `max(${bottom}px, env(safe-area-inset-bottom))`,
        zIndex: zIndex + 1,
        border: "1px solid #e5e7eb",
        background: "#111827",
        color: "#fff",
        padding: "10px 14px",
        borderRadius: 999,
        boxShadow: "0 6px 24px rgba(0,0,0,0.15)",
        cursor: "pointer",
        fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, sans-serif",
      }}
      aria-expanded={open}
      aria-controls="copilot-iframe"
      title={open ? "Hide Copilot" : "Open Copilot"}
    >
      {open ? "Close Copilot" : "Open Copilot"}
    </button>
  );

  // Keep the iframe alive for the whole component lifetime
  const portal = hostRef.current
    ? createPortal(
        <iframe
          id="copilot-iframe"
          ref={iframeRef}
          title="copilot"
          src={src}
          style={{ width: "100%", height: "100%", border: "none", display: "block" }}
        />,
        hostRef.current
      )
    : null;

  return (
    <>
      {toggleBtn}
      {portal}
    </>
  );
}




// main/src/App.js
import React from "react";
import SubappDock from "./SubappDock";

export default function App() {
  return (
    <div style={{ minHeight: "150vh", padding: 24 }}>
      <h1>Main App</h1>
      <SubappDock
        src="http://localhost:3001" // your sub-app URL
        width={420}
        height={600}
        defaultOpen={true}
        // flip to true if you ever still see a blank after reopen:
        // forceReloadOnOpen={true}
      />
    </div>
  );
}








// SubApp.jsx
import React, { useRef } from "react";
import { CopilotChat } from "@copilotkit/react-ui";
import { useCopilotChat } from "@copilotkit/react-core"; // if your version supports it

const DEFAULT_SUGGESTIONS = [
  "Show a summary of Loans",
  "List approvers for Car loan",
  "What is the outstanding balance?",
  "Employment details",
];

function SuggestionsBar({ suggestions }) {
  const { sendMessage } = useCopilotChat?.() || {}; // safe if not available
  const hostRef = useRef(null);

  // Fallback: simulate typing if hook not available
  const fallbackSend = (text) => {
    const root = hostRef.current;
    if (!root) return;
    const input = root.querySelector("textarea, input[type='text']");
    if (!input) return;
    input.value = text;
    input.dispatchEvent(new Event("input", { bubbles: true }));
    input.dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: true }));
  };

  const handleClick = (s) => {
    if (sendMessage) sendMessage(s);
    else fallbackSend(s);
  };

  return (
    <div className="sticky bottom-0 bg-white/80 backdrop-blur border-t px-3 py-2 flex flex-wrap gap-2">
      {suggestions.map((s, i) => (
        <button
          key={i}
          onClick={() => handleClick(s)}
          className="px-3 py-1 rounded-full text-sm border hover:bg-gray-50"
        >
          {s}
        </button>
      ))}
    </div>
  );
}

export default function SubApp() {
  return (
    <div className="h-screen flex flex-col" ref={el => (hostRef = el)}>
      <div className="flex-1 overflow-y-auto">
        <CopilotChat className="h-full" />
      </div>
      <SuggestionsBar suggestions={DEFAULT_SUGGESTIONS} />
    </div>
  );
}







// SubApp.jsx
import React, { useRef } from "react";
import { CopilotChat } from "@copilotkit/react-ui";
import { useCopilotChat } from "@copilotkit/react-core"; // if your version supports it

const DEFAULT_SUGGESTIONS = [
  "Show a summary of Loans",
  "List approvers for Car loan",
  "What is the outstanding balance?",
  "Employment details",
];

function SuggestionsBar({ suggestions, hostRef }) {
  const { sendMessage } = useCopilotChat?.() || {}; // safe if not available

  // Fallback: simulate typing if hook not available
  const fallbackSend = (text) => {
    const root = hostRef.current;
    if (!root) return;
    const input = root.querySelector("textarea, input[type='text']");
    if (!input) return;
    input.value = text;
    input.dispatchEvent(new Event("input", { bubbles: true }));
    input.dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: true }));
  };

  const handleClick = (s) => {
    if (sendMessage) sendMessage(s);
    else fallbackSend(s);
  };

  return (
    <div className="sticky bottom-0 bg-white/80 backdrop-blur border-t px-3 py-2 flex flex-wrap gap-2">
      {suggestions.map((s, i) => (
        <button
          key={i}
          onClick={() => handleClick(s)}
          className="px-3 py-1 rounded-full text-sm border hover:bg-gray-50"
        >
          {s}
        </button>
      ))}
    </div>
  );
}

export default function SubApp() {
  const hostRef = useRef(null);

  return (
    <div className="h-screen flex flex-col" ref={hostRef}>
      <div className="flex-1 overflow-y-auto">
        <CopilotChat className="h-full" />
      </div>
      <SuggestionsBar suggestions={DEFAULT_SUGGESTIONS} hostRef={hostRef} />
    </div>
  );
}





.chat-page {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.chat-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0; /* important for flex children to shrink */
}

/* Ensure CopilotChat uses column layout */
.chat-inner {
  display: flex;
  flex-direction: column;
  flex: 1;
}

/* First child = messages area, scrollable */
.chat-inner > :first-child {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}

/* Last child = composer, pinned to bottom */
.chat-inner > :last-child {
  margin-top: auto;
  position: sticky;
  bottom: 0;
  background: white; /* prevent overlap */
  border-top: 1px solid #eee; /* optional styling */
}







from fastapi import FastAPI
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

app = FastAPI()

class CopilotMessage(BaseModel):
    id: str
    role: str        # "user" | "assistant" | "system"
    content: str
    createdAt: Optional[datetime] = None

class CopilotRequest(BaseModel):
    messages: List[CopilotMessage]
    variables: Optional[dict] = None   # extra CopilotKit state if you use it





@app.post("/copilot")
async def copilot_handler(req: CopilotRequest):
    # Get the latest user message
    user_msg = next((m for m in reversed(req.messages) if m.role == "user"), None)

    if user_msg:
        print("User asked:", user_msg.content)

    # Example response — must return JSON that CopilotChat can display
    return {
        "message": {
            "role": "assistant",
            "content": f"I received: {user_msg.content if user_msg else 'no message'}"
        }
    }




# Get all messages
for msg in req.messages:
    print(msg.role, msg.content)

# Get last user query
last_user = [m for m in req.messages if m.role == "user"][-1]
print("Last user query:", last_user.content)








// SubApp.jsx
import { CopilotChat } from "@copilotkit/react-ui";
import { useCopilotChat } from "@copilotkit/react-core";

export default function SubApp() {
  const { sendMessage, addMessage } = useCopilotChat();

  const onSend = async (text) => {
    // send as user (lets the UI show the user bubble)
    await sendMessage(text);

    // call your FastAPI
    const res = await fetch("http://localhost:8000/copilot", {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({ messages: [{ role:"user", content:text }] })
    });
    const data = await res.json();

    // normalize any of the server shapes to text:
    const reply =
      data?.message?.content?.[0]?.text
      || data?.message?.content
      || data?.reply
      || JSON.stringify(data);

    // append assistant message explicitly
    addMessage({ role: "assistant", content: reply });
  };

  return <CopilotChat onSendMessage={onSend} className="h-screen" />;
}










// SubApp.jsx
import React, { useState } from "react";
import { CopilotChat } from "@copilotkit/react-ui";

const API_URL = "http://localhost:8000/copilot"; // your FastAPI endpoint

export default function SubApp() {
  const [messages, setMessages] = useState([
    { role: "assistant", content: "Hi! Ask me anything." }
  ]);

  async function callBackend(text) {
    const body = { messages: [{ role: "user", content: text }] };

    const res = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    const data = await res.json();

    // Normalize ANY of the known shapes to a plain string
    const reply =
      // v2 parts-style
      (Array.isArray(data?.message?.content) && data.message.content[0]?.text) ||
      // v1 plain content
      (typeof data?.message?.content === "string" && data.message.content) ||
      // very old
      data?.reply ||
      // fallback
      JSON.stringify(data);

    return reply;
  }

  // Newer CopilotChat builds
  async function handleSendMessage(text) {
    // show user message
    setMessages((m) => [...m, { role: "user", content: text }]);

    try {
      const reply = await callBackend(text);
      // show assistant message
      setMessages((m) => [...m, { role: "assistant", content: reply }]);
    } catch (e) {
      setMessages((m) => [...m, { role: "assistant", content: `Error: ${e}` }]);
    }
  }

  // Older CopilotChat builds (if it uses onMessage to receive both user & assistant)
  function handleMessage(msg) {
    // If CopilotChat invokes this with user messages, forward to backend
    if (msg?.role === "user" && msg?.content) {
      handleSendMessage(msg.content);
    }
  }

  return (
    <div className="h-screen flex flex-col">
      <CopilotChat
        className="flex-1"
        // Controlled messages
        messages={messages}
        // Newer prop: called with the raw user text
        onSendMessage={handleSendMessage}
        // Older prop: called with a message object
        onMessage={handleMessage}
      />
    </div>
  );
}