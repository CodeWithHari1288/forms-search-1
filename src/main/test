import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class JsonToSectionsText {

    private static final int MAX_VALUE_LEN = 160;
    private static final int MAX_ARRAY_ITEMS_INLINE = 5;
    private static final int MAX_ARRAY_OBJECTS_EXPANDED = 5;
    private static final boolean EMIT_COUNTS_FOR_ARRAYS = true;

    private static final Set<String> LIKELY_IDENTIFIER_KEYS =
            new HashSet<>(Arrays.asList("id", "name", "code", "key", "sku", "uuid", "number"));

    private static final ObjectMapper MAPPER = new ObjectMapper(new JsonFactory());

    public static void main(String[] args) {
        if (args.length < 1 || args.length > 2) {
            System.err.println("Usage: java JsonToSectionsText <input.json> [output.txt]");
            System.exit(1);
        }
        String inputPath = args[0];
        String outputPath = args.length == 2 ? args[1] : null;

        try (InputStream in = new FileInputStream(inputPath)) {
            JsonParser jp = MAPPER.getFactory().createParser(in);
            JsonNode root = MAPPER.readTree(jp);

            Writer writer = (outputPath == null)
                    ? new OutputStreamWriter(System.out, StandardCharsets.UTF_8)
                    : new OutputStreamWriter(new FileOutputStream(outputPath), StandardCharsets.UTF_8);

            try (BufferedWriter bw = new BufferedWriter(writer)) {
                if (root.isArray()) {
                    int idx = 0;
                    for (JsonNode item : root) {
                        emitSectionsForRecord(item, idx + 1, bw);
                        bw.write("--- End of Record " + (idx + 1) + " ---\n\n");
                        idx++;
                    }
                } else {
                    emitSectionsForRecord(root, 1, bw);
                    bw.write("--- End of Record 1 ---\n\n");
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
            System.exit(2);
        }
    }

    // ---- Per-record grouping ----
    private static void emitSectionsForRecord(JsonNode record, int recordNum, BufferedWriter bw) throws IOException {
        Map<String, LinkedHashSet<String>> sectionToStatements = new LinkedHashMap<>();

        if (!record.isObject()) {
            LinkedHashSet<String> root = sectionToStatements.computeIfAbsent("Root", k -> new LinkedHashSet<>());
            String subj = "Record " + recordNum;
            emitNodeStatements(subj, new ArrayDeque<>(Collections.singletonList(subj)), record, root);
        } else {
            ObjectNode on = (ObjectNode) record;
            Iterator<Map.Entry<String, JsonNode>> fields = on.fields();

            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> e = fields.next();
                String topKey = e.getKey();
                JsonNode val = e.getValue();

                String sectionName = toKeyLabel(topKey);
                String recordSubject = "Record " + recordNum;

                if (val.isValueNode()) {
                    LinkedHashSet<String> rootSection = sectionToStatements.computeIfAbsent("Root", k -> new LinkedHashSet<>());
                    Deque<String> path = new ArrayDeque<>();
                    path.add(recordSubject);
                    path.add(sectionName);
                    emitScalarStatement(recordSubject, path, sectionName, val, rootSection);
                } else {
                    LinkedHashSet<String> bucket = sectionToStatements.computeIfAbsent(sectionName, k -> new LinkedHashSet<>());
                    Deque<String> path = new ArrayDeque<>();
                    path.add(recordSubject);
                    path.add(sectionName);

                    if (val.isObject()) {
                        processNode(recordSubject, val, path, bucket);
                    } else if (val.isArray()) {
                        handleArray(recordSubject, sectionName, val, path, bucket);
                    }
                }
            }
        }

        // ---- Write grouped sections ----
        for (Map.Entry<String, LinkedHashSet<String>> entry : sectionToStatements.entrySet()) {
            bw.write("=== Section: " + entry.getKey() + " ===\n");
            for (String stmt : entry.getValue()) {
                bw.write(stmt);
                bw.write("\n");
            }
            bw.write("\n");
        }
    }

    // ---- Traversal ----
    private static void emitNodeStatements(String subjectSeed,
                                           Deque<String> path,
                                           JsonNode node,
                                           LinkedHashSet<String> out) {
        if (node == null || node.isNull()) return;

        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> it = node.fields();
            while (it.hasNext()) {
                Map.Entry<String, JsonNode> e = it.next();
                String key = e.getKey();
                JsonNode val = e.getValue();
                String keyLabel = toKeyLabel(key);

                Deque<String> newPath = new ArrayDeque<>(path);
                newPath.add(keyLabel);

                if (val.isObject()) {
                    emitNodeStatements(subjectSeed, newPath, val, out);
                } else if (val.isArray()) {
                    handleArray(subjectSeed, keyLabel, val, newPath, out);
                } else if (val.isValueNode()) {
                    emitScalarStatement(subjectSeed, path, keyLabel, val, out);
                }
            }
        } else if (node.isArray()) {
            handleArray(subjectSeed, "Items", node, path, out);
        } else if (node.isValueNode()) {
            String subject = compressPath(path);
            out.add(subject + " is " + normalizeValue(node) + ".");
        }
    }

    private static void processNode(String subjectSeed,
                                    JsonNode node,
                                    Deque<String> path,
                                    LinkedHashSet<String> out) {
        emitNodeStatements(subjectSeed, path, node, out);
    }

    // ---- Arrays ----
    private static void handleArray(String subjectSeed,
                                    String keyLabel,
                                    JsonNode arrayNode,
                                    Deque<String> path,
                                    LinkedHashSet<String> out) {
        ArrayNode arr = (ArrayNode) arrayNode;

        if (EMIT_COUNTS_FOR_ARRAYS) {
            String subject = compressPath(path);
            out.add(subject + " includes " + arr.size() + " " + pluralize(keyLabel) + ".");
        }
        if (arr.size() == 0) return;

        if (allPrimitives(arr)) {
            List<String> items = new ArrayList<>();
            int limit = Math.min(arr.size(), MAX_ARRAY_ITEMS_INLINE);
            for (int i = 0; i < limit; i++) items.add(normalizeValue(arr.get(i)));
            String subject = compressPath(path);
            out.add(subject + " has " + joinList(items) + ".");
        } else {
            int expanded = 0;
            for (int i = 0; i < arr.size() && expanded < MAX_ARRAY_OBJECTS_EXPANDED; i++) {
                JsonNode elem = arr.get(i);
                if (!elem.isObject()) continue;
                String itemTag = arrayItemTag((ObjectNode) elem, i);
                Deque<String> itemPath = new ArrayDeque<>(path);
                itemPath.add(itemTag);
                processNode(subjectSeed, elem, itemPath, out);
                expanded++;
            }
        }
    }

    // ---- Scalars ----
    private static void emitScalarStatement(String subjectSeed,
                                            Deque<String> path,
                                            String keyLabel,
                                            JsonNode val,
                                            LinkedHashSet<String> out) {
        String subject = compressPath(path);
        String value = normalizeValue(val);
        out.add(subject + " has " + keyLabel.toLowerCase(Locale.ROOT) + " " + value + ".");
    }

    // ---- Helpers ----
    private static boolean allPrimitives(ArrayNode arr) {
        for (JsonNode n : arr) if (!n.isValueNode()) return false;
        return true;
    }

    private static String arrayItemTag(ObjectNode obj, int index) {
        for (String k : LIKELY_IDENTIFIER_KEYS) {
            JsonNode v = obj.get(k);
            if (v != null && v.isValueNode()) {
                String val = cleanVal(v.asText());
                if (!val.isEmpty()) return toKeyLabel(k) + " " + val;
            }
        }
        return "#" + (index + 1);
    }

    private static String compressPath(Deque<String> path) {
        List<String> parts = new ArrayList<>(path);
        List<String> dedup = new ArrayList<>();
        String prev = null;
        for (String p : parts) {
            String pp = p.trim();
            if (!pp.equalsIgnoreCase(prev)) dedup.add(pp);
            prev = pp;
        }
        int n = dedup.size();
        if (n <= 3) return String.join(" ", dedup);
        return String.join(" ", dedup.subList(n - 3, n));
    }

    private static String normalizeValue(JsonNode v) {
        if (v == null || v.isNull()) return "null";
        if (v.isTextual()) {
            String s = cleanVal(v.asText());
            if (s.length() > MAX_VALUE_LEN) s = s.substring(0, MAX_VALUE_LEN) + "â€¦";
            return "\"" + s + "\"";
        }
        if (v.isNumber()) return v.numberValue().toString();
        if (v.isBoolean()) return v.asBoolean() ? "true" : "false";
        return "\"" + cleanVal(v.asText()) + "\"";
    }

    private static String cleanVal(String s) {
        if (s == null) return "";
        String t = s.trim().replaceAll("[\\r\\n\\t]+", " ");
        return t.replaceAll("\\s{2,}", " ");
    }

    private static String toKeyLabel(String key) {
        String words = key == null ? "" : key.trim();
        words = words.replaceAll("[_\\-]+", " ");
        words = words.replaceAll("(?<=[a-z])(?=[A-Z])", " ");
        words = words.replaceAll("(?<=[A-Za-z])(?=\\d)", " ");
        words = words.replaceAll("(?<=\\d)(?=[A-Za-z])", " ");
        words = words.replaceAll("\\s{2,}", " ").trim();
        return capitalize(words);
    }

    private static String capitalize(String s) {
        if (s.isEmpty()) return s;
        StringBuilder sb = new StringBuilder(s.length());
        boolean start = true;
        for (char c : s.toCharArray()) {
            if (start && Character.isLetter(c)) {
                sb.append(Character.toUpperCase(c));
                start = false;
            } else {
                sb.append(c);
            }
            if (c == ' ') start = true;
        }
        return sb.toString();
    }

    private static String pluralize(String s) {
        String w = s.toLowerCase(Locale.ROOT);
        if (w.endsWith("y") && !(w.endsWith("ay") || w.endsWith("ey") || w.endsWith("iy")
                || w.endsWith("oy") || w.endsWith("uy"))) {
            return s.substring(0, s.length() - 1) + "ies";
        }
        if (w.endsWith("s") || w.endsWith("x") || w.endsWith("z") || w.endsWith("ch") || w.endsWith("sh")) {
            return s + "es";
        }
        return s + "s";
    }

    private static String joinList(List<String> items) {
        if (items.isEmpty()) return "";
        if (items.size() == 1) return items.get(0);
        if (items.size() == 2) return items.get(0) + " and " + items.get(1);
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < items.size(); i++) {
            if (i > 0) sb.append(i == items.size() - 1 ? ", and " : ", ");
            sb.append(items.get(i));
        }
        return sb.toString();
    }
}