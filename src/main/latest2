import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * ChatCopilot.jsx
 * - Docked chat (bottom-right)
 * - "Open in new tab" -> launches a new tab with the SAME chat state
 * - Live sync between tabs via BroadcastChannel (fallback to storage events)
 */

export default function ChatCopilot() {
  // --- URL flags (full mode when opened in a tab) ---
  const params = new URLSearchParams(window.location.search);
  const isFull = params.get("copilot") === "1";
  const sidParam = params.get("sid");

  // --- Chat state ---
  const [minimized, setMinimized] = useState(false);
  const [messages, setMessages] = useState(() => [
    { role: "assistant", text: "Hi! I’m your Copilot. How can I help today?" },
  ]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);

  // Suggestions (could be server-driven)
  const suggestions = useMemo(
    () => [
      "Summarize the latest sprint notes",
      "Draft an email to the customer about release status",
      "What’s our revenue by month this quarter?",
      "Find docs on ‘data ingestion pipeline’",
    ],
    []
  );

  // --- Cross-tab sync channel ---
  const channelRef = useRef(null);
  useEffect(() => {
    try {
      channelRef.current = new BroadcastChannel("copilot-chat");
    } catch {
      channelRef.current = null; // older browsers
    }

    const onMsg = (ev) => {
      const data = ev.data || ev; // BC / storage fallback
      if (data?.type === "STATE_SYNC" && data?.payload) {
        const { messages: ms, minimized: mi, input: ip } = data.payload;
        // Avoid loops by only applying real changes
        setMessages((prev) => (JSON.stringify(prev) !== JSON.stringify(ms) ? ms : prev));
        setMinimized((prev) => (prev !== mi ? mi : prev));
        setInput((prev) => (prev !== ip ? ip : prev));
      }
    };

    if (channelRef.current) {
      channelRef.current.onmessage = onMsg;
    } else {
      // Fallback using 'storage' events
      const onStorage = (e) => {
        if (e.key === "copilot:sync" && e.newValue) {
          try {
            onMsg(JSON.parse(e.newValue));
          } catch {}
        }
      };
      window.addEventListener("storage", onStorage);
      return () => window.removeEventListener("storage", onStorage);
    }

    return () => {
      try {
        channelRef.current && channelRef.current.close();
      } catch {}
    };
  }, []);

  // Broadcast current state to other tabs
  const broadcast = (payload) => {
    const msg = { type: "STATE_SYNC", payload };
    if (channelRef.current) {
      channelRef.current.postMessage(msg);
    } else {
      localStorage.setItem("copilot:sync", JSON.stringify(msg));
      // touch to trigger storage event
      setTimeout(() => localStorage.removeItem("copilot:sync"), 0);
    }
  };

  // Keep others updated when our state changes
  useEffect(() => {
    broadcast({ messages, minimized, input });
  }, [messages, minimized, input]);

  // --- If we are the "full" tab, hydrate initial state from localStorage snapshot ---
  useEffect(() => {
    if (isFull && sidParam) {
      const snapKey = `copilot:snapshot:${sidParam}`;
      const raw = localStorage.getItem(snapKey);
      if (raw) {
        try {
          const snap = JSON.parse(raw);
          if (snap.messages) setMessages(snap.messages);
          if (typeof snap.minimized === "boolean") setMinimized(snap.minimized);
          if (typeof snap.input === "string") setInput(snap.input);
        } catch {}
      }
    }
  }, [isFull, sidParam]);

  // ---------- SEND ----------
  const sendMessage = async (text) => {
    if (!text.trim()) return;
    const userMsg = { role: "user", text };
    setMessages((m) => [...m, userMsg]);
    setInput("");
    setLoading(true);

    try {
      // Replace with your backend call (LangGraph FastAPI)
      const botText = demoResponder(text);
      setMessages((m) => [...m, { role: "assistant", text: botText }]);
    } catch {
      setMessages((m) => [
        ...m,
        { role: "assistant", text: "Sorry, I hit an error reaching the backend." },
      ]);
    } finally {
      setLoading(false);
    }
  };

  const onSuggestionClick = (s) => sendMessage(s);

  // ---------- OPEN IN NEW TAB ----------
  const openInNewTab = () => {
    const sid = cryptoRandomId();
    // snapshot current state for the new tab to hydrate
    const snapKey = `copilot:snapshot:${sid}`;
    const snapshot = { messages, minimized, input, ts: Date.now() };
    localStorage.setItem(snapKey, JSON.stringify(snapshot));

    // open same origin (same route) with flags so the full-page tab knows to hydrate
    const url = new URL(window.location.href);
    url.searchParams.set("copilot", "1");
    url.searchParams.set("sid", sid);
    window.open(url.toString(), "_blank", "noopener");
  };

  // ---------- UI ----------
  const containerStyle = isFull ? styles.fullContainer : styles.dock;
  const shellStyle = isFull ? { ...styles.shell, ...styles.shellFull } : styles.shell;

  return (
    <div style={containerStyle}>
      <div style={shellStyle} aria-live="polite" role="dialog" aria-label="Copilot chat">
        <Header
          isFull={isFull}
          minimized={minimized}
          onMinimize={() => setMinimized((v) => !v)}
          onOpenTab={openInNewTab}
        />
        {!minimized && (
          <>
            <MessagesList messages={messages} loading={loading} />
            <SuggestionsRow suggestions={suggestions} onPick={onSuggestionClick} />
            <Composer
              value={input}
              onChange={setInput}
              onSend={() => sendMessage(input)}
              disabled={loading}
            />
          </>
        )}
      </div>
    </div>
  );
}

/* ---------- Subcomponents ---------- */

function Header({ isFull, minimized, onMinimize, onOpenTab }) {
  return (
    <div style={styles.header}>
      <div style={styles.headerLeft}>
        <div style={styles.logoCircle} aria-hidden />
        <div>
          <div style={styles.title}>Copilot</div>
          <div style={styles.subtitle}>{isFull ? "Full view" : "Ready to help"}</div>
        </div>
      </div>
      <div style={styles.headerActions}>
        <button
          title={minimized ? "Restore" : "Minimize"}
          onClick={onMinimize}
          style={styles.iconBtn}
          aria-label={minimized ? "Restore chat" : "Minimize chat"}
        >
          {minimized ? "▣" : "—"}
        </button>
        {!isFull && (
          <button
            title="Open in new tab"
            onClick={onOpenTab}
            style={styles.iconBtn}
            aria-label="Open chat in new tab"
          >
            ⧉
          </button>
        )}
      </div>
    </div>
  );
}

function MessagesList({ messages, loading }) {
  const listRef = useRef(null);
  useEffect(() => {
    if (listRef.current) listRef.current.scrollTop = listRef.current.scrollHeight;
  }, [messages, loading]);

  return (
    <div ref={listRef} style={styles.messages}>
      {messages.map((m, i) => (
        <div
          key={i}
          style={{ ...styles.msgRow, justifyContent: m.role === "user" ? "flex-end" : "flex-start" }}
        >
          {m.role === "assistant" && <div style={styles.avatar} aria-hidden />}
          <div
            style={{
              ...styles.bubble,
              ...(m.role === "user" ? styles.bubbleUser : styles.bubbleAssistant),
            }}
          >
            {m.text}
          </div>
        </div>
      ))}
      {loading && (
        <div style={{ ...styles.msgRow, justifyContent: "flex-start" }}>
          <div style={styles.avatar} aria-hidden />
          <div style={{ ...styles.bubble, ...styles.bubbleAssistant }}>
            <TypingDots />
          </div>
        </div>
      )}
    </div>
  );
}

function SuggestionsRow({ suggestions, onPick }) {
  return (
    <div style={styles.suggestions}>
      {suggestions.map((s, idx) => (
        <button key={idx} style={styles.suggestionBtn} onClick={() => onPick(s)}>
          {s}
        </button>
      ))}
    </div>
  );
}

function Composer({ value, onChange, onSend, disabled }) {
  const onKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      onSend();
    }
  };
  return (
    <div style={styles.composer}>
      <textarea
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onKeyDown={onKeyDown}
        placeholder="Ask me anything..."
        rows={1}
        style={styles.textarea}
        disabled={disabled}
        aria-label="Type your message"
      />
      <button style={styles.sendBtn} onClick={onSend} disabled={disabled || !value.trim()}>
        Send
      </button>
    </div>
  );
}

function TypingDots() {
  const [dot, setDot] = useState(0);
  useEffect(() => {
    const t = setInterval(() => setDot((d) => (d + 1) % 3), 400);
    return () => clearInterval(t);
  }, []);
  return <span>{["•", "••", "•••"][dot]}</span>;
}

/* ---------- Styles ---------- */

const styles = {
  // Docked to bottom-right
  dock: {
    position: "fixed",
    right: 16,
    bottom: 16,
    zIndex: 9999,
  },
  // Full tab container (body)
  fullContainer: {
    position: "fixed",
    inset: 0,
    zIndex: 1,
    background: "#fff",
  },
  shell: {
    width: 380,
    maxHeight: "70vh",
    height: "auto",
    display: "flex",
    flexDirection: "column",
    borderRadius: 16,
    border: "1px solid rgba(0,0,0,0.08)",
    boxShadow: "0 10px 15px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.05)",
    background: "linear-gradient(180deg, #ffffff, #fafbff)",
    overflow: "hidden",
    fontFamily:
      'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"',
  },
  shellFull: {
    width: "min(960px, 92vw)",
    height: "min(86vh, 920px)",
    margin: "5vh auto",
    maxHeight: "unset",
    borderRadius: 16,
  },
  header: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
    padding: "10px 12px",
    borderBottom: "1px solid rgba(0,0,0,0.06)",
    background: "linear-gradient(180deg, #f5f7ff, #eef2ff)",
  },
  headerLeft: { display: "flex", alignItems: "center", gap: 10 },
  logoCircle: {
    width: 28,
    height: 28,
    borderRadius: "50%",
    background:
      "conic-gradient(from 180deg at 50% 50%, #2563eb, #7c3aed, #06b6d4, #2563eb)",
    boxShadow: "0 0 0 2px rgba(255,255,255,0.8)",
  },
  title: { fontWeight: 700, fontSize: 14, color: "#0f172a" },
  subtitle: { fontSize: 12, color: "#475569" },
  headerActions: { display: "flex", gap: 6 },
  iconBtn: {
    border: "none",
    background: "transparent",
    padding: "6px 8px",
    borderRadius: 8,
    cursor: "pointer",
    fontSize: 16,
    lineHeight: 1,
  },
  messages: {
    flex: 1,
    overflowY: "auto",
    padding: 12,
    background:
      "radial-gradient(1200px 400px at 100% 0, rgba(99,102,241,0.06), transparent), #fff",
  },
  msgRow: { display: "flex", gap: 8, marginBottom: 10 },
  avatar: {
    width: 28,
    height: 28,
    borderRadius: "50%",
    background:
      "conic-gradient(from 180deg at 50% 50%, #2563eb, #7c3aed, #06b6d4, #2563eb)",
    marginTop: 2,
    flexShrink: 0,
  },
  bubble: {
    maxWidth: "75%",
    padding: "8px 12px",
    borderRadius: 12,
    fontSize: 14,
    lineHeight: 1.4,
    whiteSpace: "pre-wrap",
    wordBreak: "break-word",
  },
  bubbleAssistant: { background: "#f1f5f9", color: "#0f172a", borderTopLeftRadius: 4 },
  bubbleUser: { background: "#2563eb", color: "#fff", borderTopRightRadius: 4 },
  suggestions: {
    display: "flex",
    flexWrap: "wrap",
    gap: 8,
    padding: "6px 12px 0",
  },
  suggestionBtn: {
    border: "1px solid rgba(37,99,235,0.2)",
    background: "rgba(37,99,235,0.06)",
    color: "#1e3a8a",
    padding: "6px 10px",
    borderRadius: 12,
    cursor: "pointer",
    fontSize: 12,
  },
  composer: {
    display: "flex",
    gap: 8,
    padding: 12,
    borderTop: "1px solid rgba(0,0,0,0.06)",
    background: "#fff",
  },
  textarea: {
    flex: 1,
    resize: "none",
    border: "1px solid #e2e8f0",
    borderRadius: 10,
    padding: "10px 12px",
    fontSize: 14,
    outline: "none",
  },
  sendBtn: {
    border: "none",
    background: "#2563eb",
    color: "#fff",
    padding: "10px 14px",
    borderRadius: 10,
    cursor: "pointer",
    fontWeight: 600,
  },
};

/* ---------- Helpers ---------- */

function cryptoRandomId() {
  if (window.crypto?.randomUUID) return window.crypto.randomUUID();
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

/* ---------- Demo responder (replace with backend call) ---------- */
function demoResponder(text) {
  const lower = text.toLowerCase();
  if (/(sum|total|count|average|avg|by month|group)/.test(lower)) {
    return "I can generate an SQL query against your schema and summarize the results. (Wire me to your LangGraph SQL path.)";
  }
  if (/(doc|policy|help|how)/.test(lower)) {
    return "I’ll search your knowledge base and cite top passages. (Wire me to your Chroma retriever.)";
  }
  return "Got it. I’ll pick the best tool based on your question and bring back an answer.";
}