#!/usr/bin/env python3
# JSONâ†’CSV with RFC 6901 pointers + optional template join by pointer
# - Works when the input JSON root is an OBJECT or an ARRAY OF OBJECTS.
# - Writes one CSV per JSON object into an output folder.
#
# Usage:
#   python json_to_csv_array_aware.py --json input.json --out_dir out_folder [--template template.csv]
#
# Template CSV (optional) must have at least: pointer,label,section,subsection
#   pointer must be RFC 6901 (same as we emit here)

import json, csv, sys, os
from typing import Any, List, Dict, Tuple

def esc_token(s: str) -> str:               # RFC 6901 escaping
    return s.replace("~", "~0").replace("/", "~1")

def walk(doc: Any, base: List[str] = []):
    """Yield (path_segments, scalar_value) for each scalar (leaf) in the JSON."""
    if isinstance(doc, dict):
        for k, v in doc.items():
            for res in walk(v, base + [str(k)]):
                yield res
    elif isinstance(doc, list):
        for i, v in enumerate(doc):
            for res in walk(v, base + [str(i)]):
                yield res
    else:
        # scalar value
        yield base, doc

def load_template(path: str) -> Dict[str, Dict[str,str]]:
    """
    Template CSV must have at least: pointer,label,section,subsection
    pointer must be RFC 6901 (same as we emit here)
    """
    m: Dict[str, Dict[str,str]] = {}
    if not path:
        return m
    with open(path, newline="", encoding="utf-8") as f:
        r = csv.DictReader(f)
        for row in r:
            m[row["pointer"]] = row
    return m

def write_single_csv(doc: Any, out_csv_path: str, template_map: Dict[str, Dict[str,str]]):
    """Write one CSV for a single JSON object using the original leaf-walk + pointer join logic."""
    # original columns
    cols = ["Label","propertyname","repeatable","array/listindex",
            "property value","section","subsection","pointerforjson"]

    os.makedirs(os.path.dirname(out_csv_path) or ".", exist_ok=True)
    with open(out_csv_path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=cols)
        w.writeheader()

        for path, val in walk(doc):
            ptr = "/" + "/".join(esc_token(p) for p in path)
            idxs = [int(p) for p in path if p.isdigit()]
            propname = next((p for p in reversed(path) if not p.isdigit()), "")

            t = template_map.get(ptr, {})
            w.writerow({
                "Label": t.get("label",""),
                "propertyname": propname,
                "repeatable": bool(idxs),
                "array/listindex": idxs[0] if idxs else "",
                "property value": val,
                "section": t.get("section",""),
                "subsection": t.get("subsection",""),
                "pointerforjson": ptr
            })

def basename_without_ext(path: str) -> str:
    base = os.path.basename(path)
    i = base.rfind(".")
    return base[:i] if i > 0 else base

def main():
    # simple flag parser: --json <file> --out_dir <folder> [--template <file.csv>]
    args = {}
    a = sys.argv[1:]
    i = 0
    while i < len(a):
        if a[i].startswith("--"):
            key = a[i]
            val = None
            if i + 1 < len(a) and not a[i+1].startswith("--"):
                val = a[i+1]
                i += 1
            args[key] = val
        i += 1

    in_json    = args.get("--json")
    out_dir    = args.get("--out_dir")
    template   = args.get("--template")

    if not in_json or not out_dir:
        print("Usage: --json <file.json> --out_dir <folder> [--template <template.csv>]")
        sys.exit(1)

    with open(in_json, "r", encoding="utf-8") as f:
        root = json.load(f)

    template_map = load_template(template)
    base = basename_without_ext(in_json)
    os.makedirs(out_dir, exist_ok=True)

    if isinstance(root, list):
        # One CSV per array element
        for idx, elem in enumerate(root):
            out_path = os.path.join(out_dir, f"{base}_{idx}.csv")
            write_single_csv(elem, out_path, template_map)
            print(f"Wrote {out_path}")
    else:
        # Single object
        out_path = os.path.join(out_dir, f"{base}.csv")
        write_single_csv(root, out_path, template_map)
        print(f"Wrote {out_path}")

if __name__ == "__main__":
    main()