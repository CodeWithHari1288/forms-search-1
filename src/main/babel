import React, { useState } from "react";
import { CopilotKit, useCopilotAction } from "@copilotkit/react-core";

// runtimeUrl is required by the provider, but we won't actually use it.
// The custom action handler bypasses it by doing fetch() directly.
const UNUSED_RUNTIME_URL = "http://localhost:0/unused";

function DemoForm() {
  const [query, setQuery] = useState("hello from copilot action");
  const [flag, setFlag] = useState(true);
  const [result, setResult] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);

  // Define the custom action with the hook
const sendToPython = useCopilotAction({
    name: "sendToPython",
    description: "Send custom body to FastAPI",
    parameters: [
      { name: "query", type: "string", description: "User query" },
      { name: "flag", type: "boolean", description: "Extra flag" },
    ],
    handler: async ({ query, flag }) => {
      const resp = await fetch("http://localhost:8000/myapi", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, flag, ts: new Date().toISOString() }),
      });

      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`Python API error: ${resp.status} ${txt}`);
      }

      return resp.json();
    },
  });


  return (
    <div style={{ display: "grid", gap: 12 }}>
      <label>
        Query:
        <input
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          style={{ marginLeft: 8, width: "100%" }}
        />
      </label>
      <label>
        Flag:
        <input
          type="checkbox"
          checked={flag}
          onChange={(e) => setFlag(e.target.checked)}
          style={{ marginLeft: 8 }}
        />
      </label>
     <button
  onClick={async () => {
    setError(null);
    setResult(null);
    try {
      const resp = await fetch("http://localhost:8000/myapi", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, flag }),
      });
      const out = await resp.json();
      setResult(out);
    } catch (err: any) {
      setError(err.message);
    }
  }}
>
  Send directly
</button>

      {error && (
        <pre style={{ color: "crimson", whiteSpace: "pre-wrap" }}>{error}</pre>
      )}
      {result && (
        <pre
          style={{
            background: "#f7f7f7",
            padding: 12,
            borderRadius: 8,
          }}
        >
          {JSON.stringify(result, null, 2)}
        </pre>
      )}
    </div>
  );
}

export default function App() {
  return (
    <CopilotKit runtimeUrl={UNUSED_RUNTIME_URL}>
      <div style={{ fontFamily: "Inter, system-ui, Arial", padding: 24 }}>
        <h1>CopilotKit useCopilotAction â†’ Python API</h1>
        <p>
          This demo uses the <code>useCopilotAction</code> hook to define a
          custom action that calls a FastAPI endpoint at{" "}
          <code>http://localhost:8000/myapi</code>.
        </p>
        <DemoForm />
      </div>
    </CopilotKit>
  );
}






from fastapi import FastAPI, Request
from models import Payload

app = FastAPI()

@app.post("/parse")
async def parse(req: Request):
    data = await req.json()
    payload = Payload.model_validate(data)
    # Access like Python objects:
    msgs = [
        {
            "id": m.id,
            "when": m.created_at.isoformat(),
            "role": m.text_message.role,
            "content": m.text_message.content,
        }
        for m in payload.messages
    ]
    return {"messages": msgs}




from dataclasses import dataclass
from typing import List, Optional, Dict, Any
from datetime import datetime

@dataclass
class TextMessage:
    content: str
    role: Optional[str] = None

@dataclass
class Message:
    created_at: datetime
    id: str
    text_message: TextMessage

@dataclass
class Payload:
    messages: List[Message]

def parse_payload(d: Dict[str, Any]) -> Payload:
    messages: List[Message] = []
    for m in d.get("messages", []):
        tm = m.get("textMessage", {}) or {}
        messages.append(
            Message(
                created_at=datetime.fromisoformat(
                    m["createdAt"].replace("Z", "+00:00")
                ),
                id=str(m["id"]),
                text_message=TextMessage(
                    content=str(tm.get("content", "")),
                    role=tm.get("role")
                ),
            )
        )
    return Payload(messages=messages)

# usage
incoming = {
    "messages": [
        {
            "createdAt": "2025-09-20T12:34:56Z",
            "id": "12",
            "textMessage": {"content": "aa", "role": "system"}
        }
    ]
}
payload = parse_payload(incoming)
print(payload.messages[0].text_message.content)  # "aa"
