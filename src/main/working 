

import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * ChatCopilot.jsx
 * - Docked widget in-page
 * - "Open in new tab" -> full-page with LEFT history sidebar
 * - Live sync across tabs WITHOUT blinking (instanceId + suppressBroadcast + debounce)
 */

export default function ChatCopilot() {
  const params = new URLSearchParams(window.location.search);
  const isFull = params.get("copilot") === "1";
  const sidParam = params.get("sid");

  // --- identity to avoid echo loops ---
  const instanceId = useRef(cryptoRandomId());     // unique per tab
  const suppressBroadcast = useRef(false);         // true while applying remote state

  const [minimized, setMinimized] = useState(false);
  const [messages, setMessages] = useState(() => [
    { role: "assistant", text: "Hi! I’m your Copilot. How can I help today?" },
  ]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);

  const suggestions = useMemo(
    () => [
      "Summarize the latest sprint notes",
      "Draft an email to the customer about release status",
      "What’s our revenue by month this quarter?",
      "Find docs on ‘data ingestion pipeline’",
    ],
    []
  );

  // -------- Cross-tab sync (no flicker) --------
  const channelRef = useRef(null);
  useEffect(() => {
    try { channelRef.current = new BroadcastChannel("copilot-chat"); }
    catch { channelRef.current = null; }

    const onMsg = (ev) => {
      const data = ev.data || ev;
      if (data?.type !== "STATE_SYNC" || !data?.payload) return;
      // Ignore my own messages
      if (data.from === instanceId.current) return;

      const { messages: ms, minimized: mi, input: ip } = data.payload;

      // Apply remote state without re-broadcasting
      suppressBroadcast.current = true;
      if (Array.isArray(ms)) setMessages(ms);
      if (typeof mi === "boolean") setMinimized(mi);
      if (typeof ip === "string") setInput(ip);
      // allow paint before re-enabling broadcast
      queueMicrotask(() => { suppressBroadcast.current = false; });
    };

    if (channelRef.current) {
      channelRef.current.onmessage = onMsg;
    } else {
      // storage fallback
      const onStorage = (e) => {
        if (e.key === "copilot:sync" && e.newValue) {
          try { onMsg(JSON.parse(e.newValue)); } catch {}
        }
      };
      window.addEventListener("storage", onStorage);
      return () => window.removeEventListener("storage", onStorage);
    }

    return () => { try { channelRef.current && channelRef.current.close(); } catch {} };
  }, []);

  // Debounced broadcast
  const debTimer = useRef(null);
  const broadcast = (payload) => {
    if (suppressBroadcast.current) return; // don’t echo remote updates
    const msg = { type: "STATE_SYNC", from: instanceId.current, payload };
    // debounce to coalesce rapid state changes (e.g., typing)
    clearTimeout(debTimer.current);
    debTimer.current = setTimeout(() => {
      if (channelRef.current) channelRef.current.postMessage(msg);
      else {
        localStorage.setItem("copilot:sync", JSON.stringify(msg));
        setTimeout(() => localStorage.removeItem("copilot:sync"), 0);
      }
    }, 80);
  };

  // Broadcast on local state changes only
  useEffect(() => { broadcast({ messages, minimized, input }); }, [messages, minimized, input]);

  // hydrate on full tab open
  useEffect(() => {
    if (isFull && sidParam) {
      const raw = localStorage.getItem(`copilot:snapshot:${sidParam}`);
      if (raw) {
        try {
          const snap = JSON.parse(raw);
          suppressBroadcast.current = true;
          if (snap.messages) setMessages(snap.messages);
          if (typeof snap.minimized === "boolean") setMinimized(snap.minimized);
          if (typeof snap.input === "string") setInput(snap.input);
          queueMicrotask(() => { suppressBroadcast.current = false; });
        } catch {}
      }
    }
  }, [isFull, sidParam]);

  // -------- send --------
  const sendMessage = async (text) => {
    if (!text.trim()) return;
    setMessages((m) => [...m, { role: "user", text }]);
    setInput("");
    setLoading(true);
    try {
      const botText = demoResponder(text); // replace with backend call
      setMessages((m) => [...m, { role: "assistant", text: botText }]);
    } catch {
      setMessages((m) => [...m, { role: "assistant", text: "Sorry, backend error." }]);
    } finally { setLoading(false); }
  };

  const onSuggestionClick = (s) => sendMessage(s);

  // -------- open in new tab (LEFT history layout) --------
  const openInNewTab = () => {
    const sid = cryptoRandomId();
    const snapKey = `copilot:snapshot:${sid}`;
    localStorage.setItem(snapKey, JSON.stringify({ messages, minimized, input, ts: Date.now() }));
    const url = new URL(window.location.href);
    url.searchParams.set("copilot", "1");
    url.searchParams.set("sid", sid);
    window.open(url.toString(), "_blank", "noopener");
  };

  // -------- UI containers --------
  if (isFull) {
    return (
      <div style={styles.fullGrid}>
        <Sidebar messages={messages} onPick={(t) => sendMessage(t)} />
        <div style={styles.fullMain}>
          <ChatShell
            isFull
            minimized={minimized}
            setMinimized={setMinimized}
            openInNewTab={openInNewTab}
            messages={messages}
            loading={loading}
            suggestions={suggestions}
            input={input}
            setInput={setInput}
            onSend={() => sendMessage(input)}
            onSuggestionClick={onSuggestionClick}
          />
        </div>
      </div>
    );
  }

  return (
    <div style={styles.dock}>
      <ChatShell
        isFull={false}
        minimized={minimized}
        setMinimized={setMinimized}
        openInNewTab={openInNewTab}
        messages={messages}
        loading={loading}
        suggestions={suggestions}
        input={input}
        setInput={setInput}
        onSend={() => sendMessage(input)}
        onSuggestionClick={onSuggestionClick}
      />
    </div>
  );
}

/* ---------------- Subcomponents ---------------- */

function ChatShell({
  isFull,
  minimized, setMinimized,
  openInNewTab,
  messages, loading, suggestions,
  input, setInput, onSend, onSuggestionClick
}) {
  const shellStyle = isFull ? styles.shellFull : styles.shellDock;
  return (
    <div style={shellStyle} aria-live="polite" role="dialog" aria-label="Copilot chat">
      <Header
        isFull={isFull}
        minimized={minimized}
        onMinimize={() => setMinimized((v) => !v)}
        onOpenTab={openInNewTab}
      />
      {!minimized && (
        <>
          <MessagesList messages={messages} loading={loading} />
          <SuggestionsRow suggestions={suggestions} onPick={onSuggestionClick} />
          <Composer
            value={input}
            onChange={setInput}
            onSend={onSend}
            disabled={loading}
          />
        </>
      )}
    </div>
  );
}

function Header({ isFull, minimized, onMinimize, onOpenTab }) {
  return (
    <div style={styles.header}>
      <div style={styles.headerLeft}>
        <div style={styles.logoCircle} aria-hidden />
        <div>
          <div style={styles.title}>Copilot</div>
          <div style={styles.subtitle}>{isFull ? "Full view" : "Ready to help"}</div>
        </div>
      </div>
      <div style={styles.headerActions}>
        <button
          title={minimized ? "Restore" : "Minimize"}
          onClick={onMinimize}
          style={styles.iconBtn}
          aria-label={minimized ? "Restore chat" : "Minimize chat"}
        >
          {minimized ? "▣" : "—"}
        </button>
        {!isFull && (
          <button
            title="Open in new tab"
            onClick={onOpenTab}
            style={styles.iconBtn}
            aria-label="Open chat in new tab"
          >
            ⧉
          </button>
        )}
      </div>
    </div>
  );
}

function Sidebar({ messages, onPick }) {
  const items = useMemo(() => {
    const users = messages.filter((m) => m.role === "user").slice(-50).reverse();
    return users.map((m, idx) => ({
      id: idx,
      title: m.text.slice(0, 60) + (m.text.length > 60 ? "…" : ""),
      text: m.text,
    }));
  }, [messages]);

  return (
    <aside style={styles.sidebar}>
      <div style={styles.sidebarHeader}>History</div>
      <div style={styles.sidebarList}>
        {items.length === 0 && <div style={styles.sidebarEmpty}>No recent prompts</div>}
        {items.map((it) => (
          <button key={it.id} style={styles.sidebarItem} onClick={() => onPick(it.text)}>
            {it.title}
          </button>
        ))}
      </div>
    </aside>
  );
}

function MessagesList({ messages, loading }) {
  const listRef = useRef(null);
  useEffect(() => {
    if (listRef.current) listRef.current.scrollTop = listRef.current.scrollHeight;
  }, [messages, loading]);

  return (
    <div ref={listRef} style={styles.messages}>
      {messages.map((m, i) => (
        <div
          key={i}
          style={{ ...styles.msgRow, justifyContent: m.role === "user" ? "flex-end" : "flex-start" }}
        >
          {m.role === "assistant" && <div style={styles.avatar} aria-hidden />}
          <div
            style={{
              ...styles.bubble,
              ...(m.role === "user" ? styles.bubbleUser : styles.bubbleAssistant),
            }}
          >
            {m.text}
          </div>
        </div>
      ))}
      {loading && (
        <div style={{ ...styles.msgRow, justifyContent: "flex-start" }}>
          <div style={styles.avatar} aria-hidden />
          <div style={{ ...styles.bubble, ...styles.bubbleAssistant }}>
            <TypingDots />
          </div>
        </div>
      )}
    </div>
  );
}

function SuggestionsRow({ suggestions, onPick }) {
  return (
    <div style={styles.suggestions}>
      {suggestions.map((s, idx) => (
        <button key={idx} style={styles.suggestionBtn} onClick={() => onPick(s)}>
          {s}
        </button>
      ))}
    </div>
  );
}

function Composer({ value, onChange, onSend, disabled }) {
  const onKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); onSend(); }
  };
  return (
    <div style={styles.composer}>
      <textarea
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onKeyDown={onKeyDown}
        placeholder="Ask me anything..."
        rows={1}
        style={styles.textarea}
        disabled={disabled}
        aria-label="Type your message"
      />
      <button style={styles.sendBtn} onClick={onSend} disabled={disabled || !value.trim()}>
        Send
      </button>
    </div>
  );
}

function TypingDots() {
  const [dot, setDot] = useState(0);
  useEffect(() => {
    const t = setInterval(() => setDot((d) => (d + 1) % 3), 400);
    return () => clearInterval(t);
  }, []);
  return <span>{["•", "••", "•••"][dot]}</span>;
}

/* ---------------- Styles ---------------- */

const styles = {
  dock: { position: "fixed", right: 16, bottom: 16, zIndex: 9999 },

  fullGrid: {
    position: "fixed", inset: 0, display: "grid",
    gridTemplateColumns: "300px 1fr", gridTemplateRows: "1fr", background: "#fff",
  },
  fullMain: { display: "flex", alignItems: "center", justifyContent: "center", padding: 16 },

  sidebar: {
    borderRight: "1px solid #e5e7eb", padding: 12,
    display: "flex", flexDirection: "column", gap: 8, minWidth: 0,
  },
  sidebarHeader: { fontWeight: 700, fontSize: 14, color: "#0f172a", padding: "2px 4px" },
  sidebarList: { overflowY: "auto", flex: 1, display: "flex", flexDirection: "column", gap: 6 },
  sidebarEmpty: { color: "#64748b", fontSize: 13, padding: "8px 4px" },
  sidebarItem: {
    textAlign: "left", padding: "8px 10px", borderRadius: 8,
    border: "1px solid #e5e7eb", background: "#fff", cursor: "pointer", fontSize: 13,
  },

  shellDock: {
    width: 380, maxHeight: "70vh", height: "auto",
    display: "flex", flexDirection: "column",
    borderRadius: 16, border: "1px solid rgba(0,0,0,0.08)",
    boxShadow: "0 10px 15px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.05)",
    background: "linear-gradient(180deg, #ffffff, #fafbff)",
    overflow: "hidden",
    fontFamily:
      'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"',
  },
  shellFull: {
    width: "min(980px, 92vw)", height: "min(90vh, 960px)",
    borderRadius: 16, border: "1px solid rgba(0,0,0,0.08)",
    boxShadow: "0 10px 15px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.05)",
    background: "linear-gradient(180deg, #ffffff, #fafbff)",
    display: "flex", flexDirection: "column", overflow: "hidden",
    fontFamily:
      'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"',
  },

  header: {
    display: "flex", alignItems: "center", justifyContent: "space-between", gap: 8,
    padding: "10px 12px", borderBottom: "1px solid rgba(0,0,0,0.06)",
    background: "linear-gradient(180deg, #f5f7ff, #eef2ff)",
  },
  headerLeft: { display: "flex", alignItems: "center", gap: 10 },
  logoCircle: {
    width: 28, height: 28, borderRadius: "50%", background:
      "conic-gradient(from 180deg at 50% 50%, #2563eb, #7c3aed, #06b6d4, #2563eb)",
    boxShadow: "0 0 0 2px rgba(255,255,255,0.8)",
  },
  title: { fontWeight: 700, fontSize: 14, color: "#0f172a" },
  subtitle: { fontSize: 12, color: "#475569" },
  headerActions: { display: "flex", gap: 6 },
  iconBtn: {
    border: "none", background: "transparent", padding: "6px 8px",
    borderRadius: 8, cursor: "pointer", fontSize: 16, lineHeight: 1,
  },

  messages: {
    flex: 1, overflowY: "auto", padding: 12,
    background: "radial-gradient(1200px 400px at 100% 0, rgba(99,102,241,0.06), transparent), #fff",
  },
  msgRow: { display: "flex", gap: 8, marginBottom: 10 },
  avatar: {
    width: 28, height: 28, borderRadius: "50%", background:
      "conic-gradient(from 180deg at 50% 50%, #2563eb, #7c3aed, #06b6d4, #2563eb)",
    marginTop: 2, flexShrink: 0,
  },
  bubble: {
    maxWidth: "75%", padding: "8px 12px", borderRadius: 12,
    fontSize: 14, lineHeight: 1.4, whiteSpace: "pre-wrap", wordBreak: "break-word",
  },
  bubbleAssistant: { background: "#f1f5f9", color: "#0f172a", borderTopLeftRadius: 4 },
  bubbleUser: { background: "#2563eb", color: "#fff", borderTopRightRadius: 4 },

  suggestions: { display: "flex", flexWrap: "wrap", gap: 8, padding: "6px 12px 0" },
  suggestionBtn: {
    border: "1px solid rgba(37,99,235,0.2)", background: "rgba(37,99,235,0.06)",
    color: "#1e3a8a", padding: "6px 10px", borderRadius: 12, cursor: "pointer", fontSize: 12,
  },

  composer: { display: "flex", gap: 8, padding: 12, borderTop: "1px solid rgba(0,0,0,0.06)", background: "#fff" },
  textarea: {
    flex: 1, resize: "none", border: "1px solid #e2e8f0", borderRadius: 10,
    padding: "10px 12px", fontSize: 14, outline: "none",
  },
  sendBtn: {
    border: "none", background: "#2563eb", color: "#fff",
    padding: "10px 14px", borderRadius: 10, cursor: "pointer", fontWeight: 600,
  },
};

/* ---------------- Helpers ---------------- */

function cryptoRandomId() {
  if (window.crypto?.randomUUID) return window.crypto.randomUUID();
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

/* Demo bot — replace with your LangGraph API call */
function demoResponder(text) {
  const lower = text.toLowerCase();
  if (/(sum|total|count|average|avg|by month|group)/.test(lower)) {
    return "I can generate an SQL query against your schema and summarize the results. (Wire me to your LangGraph SQL path.)";
  }
  if (/(doc|policy|help|how)/.test(lower)) {
    return "I’ll search your knowledge base and cite top passages. (Wire me to your Chroma retriever.)";
  }
  return "Got it. I’ll pick the best tool based on your question and bring back an answer.";
}








import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GroupByFirstThreeWords {

    private static final Pattern SECTION_HEADER = Pattern.compile(
            "^\\s*=+\\s*Section\\s*:\\s*([A-Za-z0-9 _-]+)\\s*=+\\s*$",
            Pattern.CASE_INSENSITIVE);

    private static final Pattern END_OF_RECORD = Pattern.compile(
            "^\\s*-{3}\\s*End\\s+of\\s+Record\\b.*$", Pattern.CASE_INSENSITIVE);

    // Capture scenario number and the tail text after it
    private static final Pattern SCEN_LINE = Pattern.compile(
            "^\\s*Scenarios\\s*#\\s*(\\d+)\\s+(.*)\\s*$",
            Pattern.CASE_INSENSITIVE);

    // Optional cleanup of leading fillers in the VALUE (not the key words)
    private static final Pattern LEAD_FILLER = Pattern.compile(
            "^(?:is|are|as)\\b\\s*[:,]*\\s*", Pattern.CASE_INSENSITIVE);

    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("Usage: java GroupByFirstThreeWords <input.txt> <output.txt>");
            System.exit(1);
        }
        process(Paths.get(args[0]), Paths.get(args[1]));
        System.out.println("Done.");
    }

    private static void process(Path in, Path out) throws IOException {
        try (BufferedReader br = Files.newBufferedReader(in, StandardCharsets.UTF_8);
             BufferedWriter bw = Files.newBufferedWriter(out, StandardCharsets.UTF_8,
                     StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

            boolean inRoot = false;

            Integer gScenario = null;
            String gKeyLower = null;              // lowercased "w1 w2 w3"
            String[] gKeyWords = null;            // original-case first three words
            List<String> gValues = new ArrayList<>();

            String line;
            while ((line = br.readLine()) != null) {
                // Section header?
                Matcher sec = SECTION_HEADER.matcher(line);
                if (sec.matches()) {
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    inRoot = sec.group(1).trim().equalsIgnoreCase("Root");
                    bw.write(line); bw.newLine();
                    continue;
                }

                // End of Record?
                if (END_OF_RECORD.matcher(line).matches()) {
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                if (!inRoot) {
                    // Outside Root: passthrough
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                // Inside Root: try scenario line
                Matcher m = SCEN_LINE.matcher(line);
                if (!m.matches()) {
                    // Not a scenario line: flush current group then passthrough
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                int scenario = Integer.parseInt(m.group(1));
                String tail = m.group(2).trim();

                String[] tokens = tail.split("\\s+");
                if (tokens.length < 3) {
                    // Not enough words to form a 3-word key; treat as a boundary
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                String w1 = tokens[0], w2 = tokens[1], w3 = tokens[2];
                String keyLower = (w1 + " " + w2 + " " + w3).toLowerCase(Locale.ROOT);

                // VALUE = everything after the first three words
                String value = tail.substring(joinLen(tokens, 0, 3)).trim();
                value = LEAD_FILLER.matcher(value).replaceFirst("").trim();
                value = trimPunct(value);
                if (value.isEmpty()) {
                    // If no meaningful value, treat as boundary and keep original line
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                // Same group?
                if (Objects.equals(gScenario, scenario) && Objects.equals(gKeyLower, keyLower)) {
                    gValues.add(value);
                    // do NOT write this original line (collapsed)
                } else {
                    // New group → flush previous then start a new one
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = scenario;
                    gKeyLower = keyLower;
                    gKeyWords = new String[]{w1, w2, w3};
                    gValues.clear();
                    gValues.add(value);
                }
            }

            // EOF: flush
            flush(bw, gScenario, gKeyWords, gValues);
        }
    }

    private static int joinLen(String[] tokens, int start, int count) {
        // returns the character length of tokens[start..start+count-1] joined with single spaces
        StringBuilder sb = new StringBuilder();
        for (int i = start; i < start + count && i < tokens.length; i++) {
            if (i > start) sb.append(' ');
            sb.append(tokens[i]);
        }
        return sb.length();
    }

    private static String trimPunct(String s) {
        return s.replaceAll("^[:;,]+\\s*", "").replaceAll("\\s*[:;,]+$", "").trim();
    }

    private static void flush(BufferedWriter bw, Integer scenario, String[] keyWords, List<String> values) throws IOException {
        if (scenario == null || keyWords == null || values == null || values.isEmpty()) return;
        bw.write("Scenarios #" + scenario + " " + keyWords[0] + " " + keyWords[1] + " " + keyWords[2] + " has ");
        for (int i = 0; i < values.size(); i++) {
            if (i > 0) bw.write(", ");
            bw.write(values.get(i));
        }
        bw.newLine();
    }
}








import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GroupTwoOrThreeWordKeys {

    private static final Pattern SECTION_HEADER = Pattern.compile(
            "^\\s*=+\\s*Section\\s*:\\s*([A-Za-z0-9 _-]+)\\s*=+\\s*$",
            Pattern.CASE_INSENSITIVE);

    private static final Pattern END_OF_RECORD = Pattern.compile(
            "^\\s*-{3}\\s*End\\s+of\\s+Record\\b.*$", Pattern.CASE_INSENSITIVE);

    private static final Pattern SCEN_LINE = Pattern.compile(
            "^\\s*Scenarios\\s*#\\s*(\\d+)\\s+(.*)\\s*$",
            Pattern.CASE_INSENSITIVE);

    private static final Pattern LEAD_FILLER = Pattern.compile(
            "^(?:is|are|as)\\b\\s*[:,]*\\s*", Pattern.CASE_INSENSITIVE);

    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("Usage: java GroupTwoOrThreeWordKeys <input.txt> <output.txt>");
            System.exit(1);
        }
        Path in = Paths.get(args[0]);
        Path out = Paths.get(args[1]);
        List<String> lines = Files.readAllLines(in, StandardCharsets.UTF_8);
        List<String> outLines = process(lines);
        Files.write(out, outLines, StandardCharsets.UTF_8,
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
        System.out.println("Done. Wrote " + out.toAbsolutePath());
    }

    private static List<String> process(List<String> lines) {
        List<String> out = new ArrayList<>();
        boolean inRoot = false;

        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);

            // Section header?
            Matcher sec = SECTION_HEADER.matcher(line);
            if (sec.matches()) {
                inRoot = sec.group(1).trim().equalsIgnoreCase("Root");
                out.add(line);
                continue;
            }

            // End of Record?
            if (END_OF_RECORD.matcher(line).matches()) {
                out.add(line);
                continue;
            }

            if (!inRoot) {
                out.add(line);
                continue;
            }

            // Inside Root — try scenario
            Matcher m = SCEN_LINE.matcher(line);
            if (!m.matches()) {
                out.add(line);
                continue;
            }

            int scenario = Integer.parseInt(m.group(1));
            String tail = m.group(2).trim();
            String[] tokens = splitWords(tail);
            if (tokens.length < 2) { // need >=2 tokens to group
                out.add(line);
                continue;
            }

            // Decide key length: prefer 3 if current AND next line share same first 3 tokens
            int keyLen = decideKeyLen(lines, i, scenario, tokens);

            // If keyLen > tokens length (e.g., only 2 tokens), cap it
            keyLen = Math.min(keyLen, tokens.length);

            String[] keyWords = Arrays.copyOfRange(tokens, 0, keyLen);
            String keyLower = String.join(" ", toLower(keyWords));

            // Collect consecutive lines in this group
            List<String> values = new ArrayList<>();
            // include current line
            String v0 = extractValue(tokens, keyLen);
            if (v0 == null) {
                // no meaningful value → just pass through this line
                out.add(line);
                continue;
            }
            values.add(v0);

            int j = i + 1;
            while (j < lines.size()) {
                String next = lines.get(j);

                // boundaries
                if (SECTION_HEADER.matcher(next).matches() ||
                    END_OF_RECORD.matcher(next).matches()) {
                    break;
                }

                Matcher nm = SCEN_LINE.matcher(next);
                if (!nm.matches()) break;

                int nScenario = Integer.parseInt(nm.group(1));
                if (nScenario != scenario) break;

                String ntail = nm.group(2).trim();
                String[] ntoks = splitWords(ntail);
                if (ntoks.length < keyLen) break;

                String[] nKeyWords = Arrays.copyOfRange(ntoks, 0, keyLen);
                String nKeyLower = String.join(" ", toLower(nKeyWords));

                if (!nKeyLower.equals(keyLower)) break; // key changed → stop grouping

                String nv = extractValue(ntoks, keyLen);
                if (nv == null) break; // treat as boundary, keep original on outer loop
                values.add(nv);
                j++;
            }

            // Emit collapsed line
            StringBuilder sb = new StringBuilder();
            sb.append("Scenarios #").append(scenario).append(' ')
              .append(String.join(" ", keyWords))
              .append(" has ");
            for (int k = 0; k < values.size(); k++) {
                if (k > 0) sb.append(", ");
                sb.append(values.get(k));
            }
            out.add(sb.toString());

            // Skip consumed lines
            i = j - 1;
        }

        return out;
    }

    private static int decideKeyLen(List<String> lines, int idx, int scenario, String[] tokens) {
        // Default to 2; upgrade to 3 if this line has >=3 tokens AND the next line matches same first 3
        if (tokens.length < 3) return 2;
        int next = idx + 1;
        if (next >= lines.size()) return 2;

        Matcher nm = SCEN_LINE.matcher(lines.get(next));
        if (!nm.matches()) return 2;
        try {
            int nScenario = Integer.parseInt(nm.group(1));
            if (nScenario != scenario) return 2;
        } catch (NumberFormatException e) {
            return 2;
        }

        String ntail = nm.group(2).trim();
        String[] ntoks = splitWords(ntail);
        if (ntoks.length < 3) return 2;

        String k3 = (tokens[0] + " " + tokens[1] + " " + tokens[2]).toLowerCase(Locale.ROOT);
        String nk3 = (ntoks[0] + " " + ntoks[1] + " " + ntoks[2]).toLowerCase(Locale.ROOT);
        return k3.equals(nk3) ? 3 : 2;
    }

    private static String extractValue(String[] tokens, int keyLen) {
        if (tokens.length <= keyLen) return null;
        StringBuilder sb = new StringBuilder();
        for (int i = keyLen; i < tokens.length; i++) {
            if (i > keyLen) sb.append(' ');
            sb.append(tokens[i]);
        }
        String val = sb.toString().trim();
        val = LEAD_FILLER.matcher(val).replaceFirst("").trim();
        val = val.replaceAll("^[:;,]+\\s*", "").replaceAll("\\s*[:;,]+$", "").trim();
        return val.isEmpty() ? null : val;
    }

    private static String[] splitWords(String s) {
        return s.trim().split("\\s+");
    }

    private static String[] toLower(String[] arr) {
        String[] out = new String[arr.length];
        for (int i = 0; i < arr.length; i++) out[i] = arr[i].toLowerCase(Locale.ROOT);
        return out;
    }
}






import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GroupInsideRootBetweenEOR {

    // Detect presence anywhere in the line (not strict equals)
    private static final Pattern ROOT_MARKER = Pattern.compile("Section\\s*:\\s*Root", Pattern.CASE_INSENSITIVE);
    private static final Pattern EOR_MARKER  = Pattern.compile("End\\s*of\\s*Record", Pattern.CASE_INSENSITIVE);

    // Scenario line: scenario number + tail
    private static final Pattern SCEN_LINE = Pattern.compile("^\\s*Scenarios\\s*#\\s*(\\d+)\\s+(.*)\\s*$",
            Pattern.CASE_INSENSITIVE);

    // Strip leading filler from value
    private static final Pattern LEAD_FILLER = Pattern.compile("^(?:is|are|as)\\b\\s*[:,]*\\s*", Pattern.CASE_INSENSITIVE);

    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("Usage: java GroupInsideRootBetweenEOR <input.txt> <output.txt>");
            System.exit(1);
        }
        Path in = Paths.get(args[0]);
        Path out = Paths.get(args[1]);
        List<String> lines = Files.readAllLines(in, StandardCharsets.UTF_8);
        List<String> outLines = process(lines);
        Files.write(out, outLines, StandardCharsets.UTF_8,
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
        System.out.println("Wrote: " + out.toAbsolutePath());
    }

    private static List<String> process(List<String> lines) {
        List<String> out = new ArrayList<>();
        boolean inRootBlock = false;  // between a line containing "Section : Root" and a subsequent line containing "End of Record"

        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);

            // Enter a Root block if we see a Root marker
            if (!inRootBlock && ROOT_MARKER.matcher(line).find()) {
                inRootBlock = true;
                out.add(line);
                continue;
            }

            if (!inRootBlock) {
                // Outside blocks: passthrough
                out.add(line);
                continue;
            }

            // Inside a Root block: check End Of Record
            if (EOR_MARKER.matcher(line).find()) {
                // Before leaving, just write the EOR line and exit block
                out.add(line);
                inRootBlock = false;
                continue;
            }

            // Try to group scenario lines starting at current index
            Matcher m = SCEN_LINE.matcher(line);
            if (!m.matches()) {
                // Not a scenario line → write through
                out.add(line);
                continue;
            }

            // Parse current scenario tokens
            int scenario = Integer.parseInt(m.group(1));
            String[] tokens = splitWords(m.group(2));
            if (tokens.length < 2) { // Need at least 2 words after "Scenarios #N" to group
                out.add(line);
                continue;
            }

            // Decide key length: prefer 3 if the next line in this block shares same first 3 words; else 2
            int keyLen = decideKeyLen(lines, i, scenario, tokens);

            // Build group
            String[] keyWords = Arrays.copyOfRange(tokens, 0, Math.min(keyLen, tokens.length));
            String keyLower = joinLower(keyWords);

            List<String> values = new ArrayList<>();
            String v0 = extractValue(tokens, keyLen);
            if (v0 == null) { // no meaningful value; just output the original line
                out.add(line);
                continue;
            }
            values.add(v0);

            int j = i + 1;
            for (; j < lines.size(); j++) {
                String nxt = lines.get(j);

                // Boundary checks **inside same Root block**:
                if (ROOT_MARKER.matcher(nxt).find()) break;             // new Root header starts (rare)
                if (EOR_MARKER.matcher(nxt).find()) break;              // End of Record ends block

                Matcher nm = SCEN_LINE.matcher(nxt);
                if (!nm.matches()) break;                                // non-scenario breaks the group

                int nScenario = Integer.parseInt(nm.group(1));
                if (nScenario != scenario) break;                         // scenario number changed

                String[] ntoks = splitWords(nm.group(2));
                if (ntoks.length < keyWords.length) break;

                String nKeyLower = joinLower(Arrays.copyOfRange(ntoks, 0, keyWords.length));
                if (!nKeyLower.equals(keyLower)) break;                   // key changed

                String nv = extractValue(ntoks, keyWords.length);
                if (nv == null) break;
                values.add(nv);
            }

            // Emit collapsed line
            StringBuilder sb = new StringBuilder();
            sb.append("Scenarios #").append(scenario).append(' ')
              .append(String.join(" ", keyWords))
              .append(" has ");
            for (int k = 0; k < values.size(); k++) {
                if (k > 0) sb.append(", ");
                sb.append(values.get(k));
            }
            out.add(sb.toString());

            // Skip consumed lines
            i = j - 1;
        }

        return out;
    }

    private static int decideKeyLen(List<String> lines, int idx, int scenario, String[] tokens) {
        if (tokens.length < 3) return 2;  // can't use 3 if we don't have it
        int next = idx + 1;
        if (next >= lines.size()) return 2;

        String cand = lines.get(next);
        // Must still be in Root block: don't cross EOR
        if (EOR_MARKER.matcher(cand).find()) return 2;

        Matcher nm = SCEN_LINE.matcher(cand);
        if (!nm.matches()) return 2;

        try {
            int nScenario = Integer.parseInt(nm.group(1));
            if (nScenario != scenario) return 2;
        } catch (NumberFormatException e) {
            return 2;
        }

        String[] ntoks = splitWords(nm.group(2));
        if (ntoks.length < 3) return 2;

        String k3 = (tokens[0] + " " + tokens[1] + " " + tokens[2]).toLowerCase(Locale.ROOT);
        String nk3 = (ntoks[0] + " " + ntoks[1] + " " + ntoks[2]).toLowerCase(Locale.ROOT);
        return k3.equals(nk3) ? 3 : 2;
    }

    private static String[] splitWords(String s) {
        return s.trim().split("\\s+");
    }

    private static String joinLower(String[] arr) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(' ');
            sb.append(arr[i].toLowerCase(Locale.ROOT));
        }
        return sb.toString();
    }

    private static String extractValue(String[] tokens, int keyLen) {
        if (tokens.length <= keyLen) return null;
        StringBuilder sb = new StringBuilder();
        for (int i = keyLen; i < tokens.length; i++) {
            if (i > keyLen) sb.append(' ');
            sb.append(tokens[i]);
        }
        String val = sb.toString().trim();
        val = LEAD_FILLER.matcher(val).replaceFirst("").trim();
        val = val.replaceAll("^[:;,]+\\s*", "").replaceAll("\\s*[:;,]+$", "").trim();
        return val.isEmpty() ? null : val;
    }
}









import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class WordReplacer {

    public static void main(String[] args) throws Exception {
        if (args.length < 3) {
            System.err.println("Usage: java WordReplacer <input.txt> <replacements.csv> <output.txt>");
            System.err.println(" - replacements.csv format: from,to (one per line; # for comments)");
            System.exit(1);
        }
        Path input = Paths.get(args[0]);
        Path mapCsv = Paths.get(args[1]);
        Path output = Paths.get(args[2]);

        // Load mapping
        Map<String, String> map = loadMapping(mapCsv);

        // Build a single regex that matches any key as a whole word (longest first)
        Pattern pattern = buildAlternationPattern(map.keySet());

        String text = new String(Files.readAllBytes(input), StandardCharsets.UTF_8);
        String replaced = replaceAll(text, pattern, map);

        Files.write(output, replaced.getBytes(StandardCharsets.UTF_8),
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

        System.out.println("Done. Wrote: " + output.toAbsolutePath());
    }

    /** Load "from,to" CSV into a case-insensitive map (keys stored lowercase). */
    private static Map<String, String> loadMapping(Path csv) throws IOException {
        Map<String, String> map = new LinkedHashMap<>();
        try (BufferedReader br = Files.newBufferedReader(csv, StandardCharsets.UTF_8)) {
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith("#")) continue;
                String[] parts = line.split(",", 2);
                if (parts.length < 2) continue;
                String from = parts[0].trim();
                String to = parts[1].trim();
                if (!from.isEmpty()) {
                    map.put(from.toLowerCase(Locale.ROOT), to);
                }
            }
        }
        return map;
    }

    /**
     * Build a case-insensitive alternation pattern with whole-word boundaries.
     * Example: \b(?:Mgmt|txt|addr)\b  (keys sorted by descending length)
     */
    private static Pattern buildAlternationPattern(Set<String> keys) {
        List<String> sorted = new ArrayList<>(keys);
        // Longest first to avoid partial matches overshadowing longer ones
        sorted.sort((a, b) -> Integer.compare(b.length(), a.length()));

        StringBuilder alt = new StringBuilder();
        alt.append("\\b(?:");
        boolean first = true;
        for (String k : sorted) {
            if (!first) alt.append("|");
            alt.append(Pattern.quote(k));
            first = false;
        }
        alt.append(")\\b");
        // Case-insensitive + Unicode-aware word boundaries are good enough here
        return Pattern.compile(alt.toString(), Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
    }

    /** Replace all matches using map, preserving the original token's casing style. */
    private static String replaceAll(String text, Pattern pattern, Map<String, String> lowerMap) {
        Matcher m = pattern.matcher(text);
        StringBuffer sb = new StringBuffer();
        while (m.find()) {
            String original = m.group();
            String keyLower = original.toLowerCase(Locale.ROOT);
            String replacement = lowerMap.getOrDefault(keyLower, original);
            String cased = matchCase(replacement, original);
            m.appendReplacement(sb, Matcher.quoteReplacement(cased));
        }
        m.appendTail(sb);
        return sb.toString();
    }

    /**
     * Simple case preservation:
     *  - ALL CAPS   -> make replacement UPPER
     *  - First Caps -> Capitalize replacement
     *  - lower      -> keep replacement lower
     *  - Mixed      -> leave replacement as-is
     */
    private static String matchCase(String replacement, String original) {
        if (original.equals(original.toUpperCase(Locale.ROOT))) {
            return replacement.toUpperCase(Locale.ROOT);
        }
        if (original.equals(original.toLowerCase(Locale.ROOT))) {
            return replacement.toLowerCase(Locale.ROOT);
        }
        if (isTitleCase(original)) {
            return capitalize(replacement);
        }
        return replacement; // mixed case → leave mapping's case
    }

    private static boolean isTitleCase(String s) {
        if (s.isEmpty()) return false;
        char first = s.charAt(0);
        return Character.isUpperCase(first) && s.substring(1).equals(s.substring(1).toLowerCase(Locale.ROOT));
    }

    private static String capitalize(String s) {
        if (s.isEmpty()) return s;
        return s.substring(0, 1).toUpperCase(Locale.ROOT) + s.substring(1).toLowerCase(Locale.ROOT);
    }
}