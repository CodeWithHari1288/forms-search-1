import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * ChatCopilot.jsx
 * - Docked widget in-page
 * - "Open in new tab" -> full-page with LEFT history sidebar
 * - Live sync across tabs WITHOUT blinking (instanceId + suppressBroadcast + debounce)
 */

export default function ChatCopilot() {
  const params = new URLSearchParams(window.location.search);
  const isFull = params.get("copilot") === "1";
  const sidParam = params.get("sid");

  // --- identity to avoid echo loops ---
  const instanceId = useRef(cryptoRandomId());     // unique per tab
  const suppressBroadcast = useRef(false);         // true while applying remote state

  const [minimized, setMinimized] = useState(false);
  const [messages, setMessages] = useState(() => [
    { role: "assistant", text: "Hi! I’m your Copilot. How can I help today?" },
  ]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);

  const suggestions = useMemo(
    () => [
      "Summarize the latest sprint notes",
      "Draft an email to the customer about release status",
      "What’s our revenue by month this quarter?",
      "Find docs on ‘data ingestion pipeline’",
    ],
    []
  );

  // -------- Cross-tab sync (no flicker) --------
  const channelRef = useRef(null);
  useEffect(() => {
    try { channelRef.current = new BroadcastChannel("copilot-chat"); }
    catch { channelRef.current = null; }

    const onMsg = (ev) => {
      const data = ev.data || ev;
      if (data?.type !== "STATE_SYNC" || !data?.payload) return;
      // Ignore my own messages
      if (data.from === instanceId.current) return;

      const { messages: ms, minimized: mi, input: ip } = data.payload;

      // Apply remote state without re-broadcasting
      suppressBroadcast.current = true;
      if (Array.isArray(ms)) setMessages(ms);
      if (typeof mi === "boolean") setMinimized(mi);
      if (typeof ip === "string") setInput(ip);
      // allow paint before re-enabling broadcast
      queueMicrotask(() => { suppressBroadcast.current = false; });
    };

    if (channelRef.current) {
      channelRef.current.onmessage = onMsg;
    } else {
      // storage fallback
      const onStorage = (e) => {
        if (e.key === "copilot:sync" && e.newValue) {
          try { onMsg(JSON.parse(e.newValue)); } catch {}
        }
      };
      window.addEventListener("storage", onStorage);
      return () => window.removeEventListener("storage", onStorage);
    }

    return () => { try { channelRef.current && channelRef.current.close(); } catch {} };
  }, []);

  // Debounced broadcast
  const debTimer = useRef(null);
  const broadcast = (payload) => {
    if (suppressBroadcast.current) return; // don’t echo remote updates
    const msg = { type: "STATE_SYNC", from: instanceId.current, payload };
    // debounce to coalesce rapid state changes (e.g., typing)
    clearTimeout(debTimer.current);
    debTimer.current = setTimeout(() => {
      if (channelRef.current) channelRef.current.postMessage(msg);
      else {
        localStorage.setItem("copilot:sync", JSON.stringify(msg));
        setTimeout(() => localStorage.removeItem("copilot:sync"), 0);
      }
    }, 80);
  };

  // Broadcast on local state changes only
  useEffect(() => { broadcast({ messages, minimized, input }); }, [messages, minimized, input]);

  // hydrate on full tab open
  useEffect(() => {
    if (isFull && sidParam) {
      const raw = localStorage.getItem(`copilot:snapshot:${sidParam}`);
      if (raw) {
        try {
          const snap = JSON.parse(raw);
          suppressBroadcast.current = true;
          if (snap.messages) setMessages(snap.messages);
          if (typeof snap.minimized === "boolean") setMinimized(snap.minimized);
          if (typeof snap.input === "string") setInput(snap.input);
          queueMicrotask(() => { suppressBroadcast.current = false; });
        } catch {}
      }
    }
  }, [isFull, sidParam]);

  // -------- send --------
  const sendMessage = async (text) => {
    if (!text.trim()) return;
    setMessages((m) => [...m, { role: "user", text }]);
    setInput("");
    setLoading(true);
    try {
      const botText = demoResponder(text); // replace with backend call
      setMessages((m) => [...m, { role: "assistant", text: botText }]);
    } catch {
      setMessages((m) => [...m, { role: "assistant", text: "Sorry, backend error." }]);
    } finally { setLoading(false); }
  };

  const onSuggestionClick = (s) => sendMessage(s);

  // -------- open in new tab (LEFT history layout) --------
  const openInNewTab = () => {
    const sid = cryptoRandomId();
    const snapKey = `copilot:snapshot:${sid}`;
    localStorage.setItem(snapKey, JSON.stringify({ messages, minimized, input, ts: Date.now() }));
    const url = new URL(window.location.href);
    url.searchParams.set("copilot", "1");
    url.searchParams.set("sid", sid);
    window.open(url.toString(), "_blank", "noopener");
  };

  // -------- UI containers --------
  if (isFull) {
    return (
      <div style={styles.fullGrid}>
        <Sidebar messages={messages} onPick={(t) => sendMessage(t)} />
        <div style={styles.fullMain}>
          <ChatShell
            isFull
            minimized={minimized}
            setMinimized={setMinimized}
            openInNewTab={openInNewTab}
            messages={messages}
            loading={loading}
            suggestions={suggestions}
            input={input}
            setInput={setInput}
            onSend={() => sendMessage(input)}
            onSuggestionClick={onSuggestionClick}
          />
        </div>
      </div>
    );
  }

  return (
    <div style={styles.dock}>
      <ChatShell
        isFull={false}
        minimized={minimized}
        setMinimized={setMinimized}
        openInNewTab={openInNewTab}
        messages={messages}
        loading={loading}
        suggestions={suggestions}
        input={input}
        setInput={setInput}
        onSend={() => sendMessage(input)}
        onSuggestionClick={onSuggestionClick}
      />
    </div>
  );
}

/* ---------------- Subcomponents ---------------- */

function ChatShell({
  isFull,
  minimized, setMinimized,
  openInNewTab,
  messages, loading, suggestions,
  input, setInput, onSend, onSuggestionClick
}) {
  const shellStyle = isFull ? styles.shellFull : styles.shellDock;
  return (
    <div style={shellStyle} aria-live="polite" role="dialog" aria-label="Copilot chat">
      <Header
        isFull={isFull}
        minimized={minimized}
        onMinimize={() => setMinimized((v) => !v)}
        onOpenTab={openInNewTab}
      />
      {!minimized && (
        <>
          <MessagesList messages={messages} loading={loading} />
          <SuggestionsRow suggestions={suggestions} onPick={onSuggestionClick} />
          <Composer
            value={input}
            onChange={setInput}
            onSend={onSend}
            disabled={loading}
          />
        </>
      )}
    </div>
  );
}

function Header({ isFull, minimized, onMinimize, onOpenTab }) {
  return (
    <div style={styles.header}>
      <div style={styles.headerLeft}>
        <div style={styles.logoCircle} aria-hidden />
        <div>
          <div style={styles.title}>Copilot</div>
          <div style={styles.subtitle}>{isFull ? "Full view" : "Ready to help"}</div>
        </div>
      </div>
      <div style={styles.headerActions}>
        <button
          title={minimized ? "Restore" : "Minimize"}
          onClick={onMinimize}
          style={styles.iconBtn}
          aria-label={minimized ? "Restore chat" : "Minimize chat"}
        >
          {minimized ? "▣" : "—"}
        </button>
        {!isFull && (
          <button
            title="Open in new tab"
            onClick={onOpenTab}
            style={styles.iconBtn}
            aria-label="Open chat in new tab"
          >
            ⧉
          </button>
        )}
      </div>
    </div>
  );
}

function Sidebar({ messages, onPick }) {
  const items = useMemo(() => {
    const users = messages.filter((m) => m.role === "user").slice(-50).reverse();
    return users.map((m, idx) => ({
      id: idx,
      title: m.text.slice(0, 60) + (m.text.length > 60 ? "…" : ""),
      text: m.text,
    }));
  }, [messages]);

  return (
    <aside style={styles.sidebar}>
      <div style={styles.sidebarHeader}>History</div>
      <div style={styles.sidebarList}>
        {items.length === 0 && <div style={styles.sidebarEmpty}>No recent prompts</div>}
        {items.map((it) => (
          <button key={it.id} style={styles.sidebarItem} onClick={() => onPick(it.text)}>
            {it.title}
          </button>
        ))}
      </div>
    </aside>
  );
}

function MessagesList({ messages, loading }) {
  const listRef = useRef(null);
  useEffect(() => {
    if (listRef.current) listRef.current.scrollTop = listRef.current.scrollHeight;
  }, [messages, loading]);

  return (
    <div ref={listRef} style={styles.messages}>
      {messages.map((m, i) => (
        <div
          key={i}
          style={{ ...styles.msgRow, justifyContent: m.role === "user" ? "flex-end" : "flex-start" }}
        >
          {m.role === "assistant" && <div style={styles.avatar} aria-hidden />}
          <div
            style={{
              ...styles.bubble,
              ...(m.role === "user" ? styles.bubbleUser : styles.bubbleAssistant),
            }}
          >
            {m.text}
          </div>
        </div>
      ))}
      {loading && (
        <div style={{ ...styles.msgRow, justifyContent: "flex-start" }}>
          <div style={styles.avatar} aria-hidden />
          <div style={{ ...styles.bubble, ...styles.bubbleAssistant }}>
            <TypingDots />
          </div>
        </div>
      )}
    </div>
  );
}

function SuggestionsRow({ suggestions, onPick }) {
  return (
    <div style={styles.suggestions}>
      {suggestions.map((s, idx) => (
        <button key={idx} style={styles.suggestionBtn} onClick={() => onPick(s)}>
          {s}
        </button>
      ))}
    </div>
  );
}

function Composer({ value, onChange, onSend, disabled }) {
  const onKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); onSend(); }
  };
  return (
    <div style={styles.composer}>
      <textarea
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onKeyDown={onKeyDown}
        placeholder="Ask me anything..."
        rows={1}
        style={styles.textarea}
        disabled={disabled}
        aria-label="Type your message"
      />
      <button style={styles.sendBtn} onClick={onSend} disabled={disabled || !value.trim()}>
        Send
      </button>
    </div>
  );
}

function TypingDots() {
  const [dot, setDot] = useState(0);
  useEffect(() => {
    const t = setInterval(() => setDot((d) => (d + 1) % 3), 400);
    return () => clearInterval(t);
  }, []);
  return <span>{["•", "••", "•••"][dot]}</span>;
}

/* ---------------- Styles ---------------- */

const styles = {
  dock: { position: "fixed", right: 16, bottom: 16, zIndex: 9999 },

  fullGrid: {
    position: "fixed", inset: 0, display: "grid",
    gridTemplateColumns: "300px 1fr", gridTemplateRows: "1fr", background: "#fff",
  },
  fullMain: { display: "flex", alignItems: "center", justifyContent: "center", padding: 16 },

  sidebar: {
    borderRight: "1px solid #e5e7eb", padding: 12,
    display: "flex", flexDirection: "column", gap: 8, minWidth: 0,
  },
  sidebarHeader: { fontWeight: 700, fontSize: 14, color: "#0f172a", padding: "2px 4px" },
  sidebarList: { overflowY: "auto", flex: 1, display: "flex", flexDirection: "column", gap: 6 },
  sidebarEmpty: { color: "#64748b", fontSize: 13, padding: "8px 4px" },
  sidebarItem: {
    textAlign: "left", padding: "8px 10px", borderRadius: 8,
    border: "1px solid #e5e7eb", background: "#fff", cursor: "pointer", fontSize: 13,
  },

  shellDock: {
    width: 380, maxHeight: "70vh", height: "auto",
    display: "flex", flexDirection: "column",
    borderRadius: 16, border: "1px solid rgba(0,0,0,0.08)",
    boxShadow: "0 10px 15px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.05)",
    background: "linear-gradient(180deg, #ffffff, #fafbff)",
    overflow: "hidden",
    fontFamily:
      'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"',
  },
  shellFull: {
    width: "min(980px, 92vw)", height: "min(90vh, 960px)",
    borderRadius: 16, border: "1px solid rgba(0,0,0,0.08)",
    boxShadow: "0 10px 15px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.05)",
    background: "linear-gradient(180deg, #ffffff, #fafbff)",
    display: "flex", flexDirection: "column", overflow: "hidden",
    fontFamily:
      'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"',
  },

  header: {
    display: "flex", alignItems: "center", justifyContent: "space-between", gap: 8,
    padding: "10px 12px", borderBottom: "1px solid rgba(0,0,0,0.06)",
    background: "linear-gradient(180deg, #f5f7ff, #eef2ff)",
  },
  headerLeft: { display: "flex", alignItems: "center", gap: 10 },
  logoCircle: {
    width: 28, height: 28, borderRadius: "50%", background:
      "conic-gradient(from 180deg at 50% 50%, #2563eb, #7c3aed, #06b6d4, #2563eb)",
    boxShadow: "0 0 0 2px rgba(255,255,255,0.8)",
  },
  title: { fontWeight: 700, fontSize: 14, color: "#0f172a" },
  subtitle: { fontSize: 12, color: "#475569" },
  headerActions: { display: "flex", gap: 6 },
  iconBtn: {
    border: "none", background: "transparent", padding: "6px 8px",
    borderRadius: 8, cursor: "pointer", fontSize: 16, lineHeight: 1,
  },

  messages: {
    flex: 1, overflowY: "auto", padding: 12,
    background: "radial-gradient(1200px 400px at 100% 0, rgba(99,102,241,0.06), transparent), #fff",
  },
  msgRow: { display: "flex", gap: 8, marginBottom: 10 },
  avatar: {
    width: 28, height: 28, borderRadius: "50%", background:
      "conic-gradient(from 180deg at 50% 50%, #2563eb, #7c3aed, #06b6d4, #2563eb)",
    marginTop: 2, flexShrink: 0,
  },
  bubble: {
    maxWidth: "75%", padding: "8px 12px", borderRadius: 12,
    fontSize: 14, lineHeight: 1.4, whiteSpace: "pre-wrap", wordBreak: "break-word",
  },
  bubbleAssistant: { background: "#f1f5f9", color: "#0f172a", borderTopLeftRadius: 4 },
  bubbleUser: { background: "#2563eb", color: "#fff", borderTopRightRadius: 4 },

  suggestions: { display: "flex", flexWrap: "wrap", gap: 8, padding: "6px 12px 0" },
  suggestionBtn: {
    border: "1px solid rgba(37,99,235,0.2)", background: "rgba(37,99,235,0.06)",
    color: "#1e3a8a", padding: "6px 10px", borderRadius: 12, cursor: "pointer", fontSize: 12,
  },

  composer: { display: "flex", gap: 8, padding: 12, borderTop: "1px solid rgba(0,0,0,0.06)", background: "#fff" },
  textarea: {
    flex: 1, resize: "none", border: "1px solid #e2e8f0", borderRadius: 10,
    padding: "10px 12px", fontSize: 14, outline: "none",
  },
  sendBtn: {
    border: "none", background: "#2563eb", color: "#fff",
    padding: "10px 14px", borderRadius: 10, cursor: "pointer", fontWeight: 600,
  },
};

/* ---------------- Helpers ---------------- */

function cryptoRandomId() {
  if (window.crypto?.randomUUID) return window.crypto.randomUUID();
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

/* Demo bot — replace with your LangGraph API call */
function demoResponder(text) {
  const lower = text.toLowerCase();
  if (/(sum|total|count|average|avg|by month|group)/.test(lower)) {
    return "I can generate an SQL query against your schema and summarize the results. (Wire me to your LangGraph SQL path.)";
  }
  if (/(doc|policy|help|how)/.test(lower)) {
    return "I’ll search your knowledge base and cite top passages. (Wire me to your Chroma retriever.)";
  }
  return "Got it. I’ll pick the best tool based on your question and bring back an answer.";
}








import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GroupByFirstThreeWords {

    private static final Pattern SECTION_HEADER = Pattern.compile(
            "^\\s*=+\\s*Section\\s*:\\s*([A-Za-z0-9 _-]+)\\s*=+\\s*$",
            Pattern.CASE_INSENSITIVE);

    private static final Pattern END_OF_RECORD = Pattern.compile(
            "^\\s*-{3}\\s*End\\s+of\\s+Record\\b.*$", Pattern.CASE_INSENSITIVE);

    // Capture scenario number and the tail text after it
    private static final Pattern SCEN_LINE = Pattern.compile(
            "^\\s*Scenarios\\s*#\\s*(\\d+)\\s+(.*)\\s*$",
            Pattern.CASE_INSENSITIVE);

    // Optional cleanup of leading fillers in the VALUE (not the key words)
    private static final Pattern LEAD_FILLER = Pattern.compile(
            "^(?:is|are|as)\\b\\s*[:,]*\\s*", Pattern.CASE_INSENSITIVE);

    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("Usage: java GroupByFirstThreeWords <input.txt> <output.txt>");
            System.exit(1);
        }
        process(Paths.get(args[0]), Paths.get(args[1]));
        System.out.println("Done.");
    }

    private static void process(Path in, Path out) throws IOException {
        try (BufferedReader br = Files.newBufferedReader(in, StandardCharsets.UTF_8);
             BufferedWriter bw = Files.newBufferedWriter(out, StandardCharsets.UTF_8,
                     StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

            boolean inRoot = false;

            Integer gScenario = null;
            String gKeyLower = null;              // lowercased "w1 w2 w3"
            String[] gKeyWords = null;            // original-case first three words
            List<String> gValues = new ArrayList<>();

            String line;
            while ((line = br.readLine()) != null) {
                // Section header?
                Matcher sec = SECTION_HEADER.matcher(line);
                if (sec.matches()) {
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    inRoot = sec.group(1).trim().equalsIgnoreCase("Root");
                    bw.write(line); bw.newLine();
                    continue;
                }

                // End of Record?
                if (END_OF_RECORD.matcher(line).matches()) {
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                if (!inRoot) {
                    // Outside Root: passthrough
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                // Inside Root: try scenario line
                Matcher m = SCEN_LINE.matcher(line);
                if (!m.matches()) {
                    // Not a scenario line: flush current group then passthrough
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                int scenario = Integer.parseInt(m.group(1));
                String tail = m.group(2).trim();

                String[] tokens = tail.split("\\s+");
                if (tokens.length < 3) {
                    // Not enough words to form a 3-word key; treat as a boundary
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                String w1 = tokens[0], w2 = tokens[1], w3 = tokens[2];
                String keyLower = (w1 + " " + w2 + " " + w3).toLowerCase(Locale.ROOT);

                // VALUE = everything after the first three words
                String value = tail.substring(joinLen(tokens, 0, 3)).trim();
                value = LEAD_FILLER.matcher(value).replaceFirst("").trim();
                value = trimPunct(value);
                if (value.isEmpty()) {
                    // If no meaningful value, treat as boundary and keep original line
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = null; gKeyLower = null; gKeyWords = null; gValues.clear();

                    bw.write(line); bw.newLine();
                    continue;
                }

                // Same group?
                if (Objects.equals(gScenario, scenario) && Objects.equals(gKeyLower, keyLower)) {
                    gValues.add(value);
                    // do NOT write this original line (collapsed)
                } else {
                    // New group → flush previous then start a new one
                    flush(bw, gScenario, gKeyWords, gValues);
                    gScenario = scenario;
                    gKeyLower = keyLower;
                    gKeyWords = new String[]{w1, w2, w3};
                    gValues.clear();
                    gValues.add(value);
                }
            }

            // EOF: flush
            flush(bw, gScenario, gKeyWords, gValues);
        }
    }

    private static int joinLen(String[] tokens, int start, int count) {
        // returns the character length of tokens[start..start+count-1] joined with single spaces
        StringBuilder sb = new StringBuilder();
        for (int i = start; i < start + count && i < tokens.length; i++) {
            if (i > start) sb.append(' ');
            sb.append(tokens[i]);
        }
        return sb.length();
    }

    private static String trimPunct(String s) {
        return s.replaceAll("^[:;,]+\\s*", "").replaceAll("\\s*[:;,]+$", "").trim();
    }

    private static void flush(BufferedWriter bw, Integer scenario, String[] keyWords, List<String> values) throws IOException {
        if (scenario == null || keyWords == null || values == null || values.isEmpty()) return;
        bw.write("Scenarios #" + scenario + " " + keyWords[0] + " " + keyWords[1] + " " + keyWords[2] + " has ");
        for (int i = 0; i < values.size(); i++) {
            if (i > 0) bw.write(", ");
            bw.write(values.get(i));
        }
        bw.newLine();
    }
}